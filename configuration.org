#+title: Emacs Configuration
#+startup: overview

* Introduction

This document is a way for me to organize and navigate my
configuration. It's not a teaching moment or an exercise in literate
programming.

* Appearance
** Emacs GUI

This goes first so that we don't see unsightly stuff appear while
Emacs is loading.

#+begin_src emacs-lisp
  (when (display-graphic-p)
    (menu-bar-mode 1)
    (tool-bar-mode -1)
    (scroll-bar-mode -1)
    (tooltip-mode -1))
#+end_src

** All the icons

#+begin_src emacs-lisp
  (use-package all-the-icons
    :ensure t)
#+end_src

** Fonts

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (when (display-graphic-p)
      (defvar kfi/font-choices '("JetBrains Mono" "Menlo" "Monaco")
        "Font faces I'm fond of.")

      (defun kfi/switch-font ()
        "Choose a font."
        (interactive)
        (let ((font (completing-read "Font:" kfi/font-choices)))
          (if font
              (set-face-attribute 'default nil :family font)
            (message "ERROR: Invalid font: %s." font))))

      (set-face-attribute 'default nil
                          :family "JetBrains Mono"
                          :height 140
                          :weight 'medium)))
#+end_src

** Themes

A light theme:

#+begin_src emacs-lisp
  (use-package modus-operandi-theme     ; light
    :ensure t
    :config
    (setq modus-operandi-theme-slanted-constructs t)
    (setq modus-operandi-theme-bold-constructs t)
    (setq modus-operandi-theme-proportional-fonts nil)
    (setq modus-operandi-theme-distinct-org-blocks t)
    (setq modus-operandi-theme-visible-fringes nil)
    (setq modus-operandi-theme-scale-headings nil))
#+end_src

The corresponding dark theme:

#+begin_src emacs-lisp
  (use-package modus-vivendi-theme      ; dark
    :ensure t
    :config
    (setq modus-vivendi-theme-slanted-constructs t)
    (setq modus-vivendi-theme-bold-constructs t)
    (setq modus-vivendi-theme-proportional-fonts nil)
    (setq modus-vivendi-theme-distinct-org-blocks t)
    (setq modus-vivendi-theme-visible-fringes nil)
    (setq modus-vivendi-theme-scale-headings nil))
#+end_src

Add a face for =Org Mode= checklists such that when you check them off,
they grey out and get a strike through. The regex matcher isn't
perfect because you can make your text contain another checklist, such
as:

#+begin_example
  - [ ] Finish the task 2) [X] again
#+end_example

The word "again" will get the font face. I need to check for
spaces/nums at the beginning, or something: or just don't do the kind
of thing up there.

#+begin_src emacs-lisp
  (defface org-checkbox-done-text '((t (:inherit org-done)))
    "Face for the text part of a checked org-mode checkbox.")

  (font-lock-add-keywords
   'org-mode
   `(("^\\(.*?[\\)\\.\\+\\-]+? \\[X\\] \\)\\(.*\\)$"
      2 ;; use the second match
      'org-checkbox-done-text prepend))
   'append)

  (set-face-attribute 'org-checkbox-done-text nil
                      :strike-through t
                      :foreground "gray40")
#+end_src

Some utility functions for switching themes. The dark theme switcher
updates an =Org Mode= face, so it has to be loaded /after/ =Org Mode=.

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (defun kfi/unload-themes ()
      "Disable all custom themes."
      (interactive)
      (dolist (theme custom-enabled-themes)
        (disable-theme theme)))

    (defun kfi/modus-light ()
      "Use the modus light theme."
      (interactive)
      (kfi/unload-themes)
      (load-theme 'modus-operandi t)
      (set-face-attribute 'mode-line nil :box nil)
      (set-face-attribute 'org-headline-done nil :strike-through t :foreground "gray40"))

    (with-eval-after-load 'org
      (defun kfi/modus-dark ()
        "Use the modus dark theme."
        (interactive)
        (kfi/unload-themes)
        (load-theme 'modus-vivendi t)
        (set-face-attribute 'mode-line nil :box nil)
        (set-face-attribute 'org-default nil :foreground "#c7c7c7")
        (set-face-attribute 'org-headline-done nil :strike-through t :foreground "gray40"))
      (when (display-graphic-p)
        (kfi/modus-dark))))
#+end_src

** Modeline

[[https://github.com/seagle0128/doom-modeline]]

#+begin_src emacs-lisp
  (use-package emacs
    :config
    (use-package doom-modeline
      :ensure t
      :config
      (when (display-graphic-p)
        (doom-modeline-mode 1)
        ;; Some themes set this, so unset it just in case.
        (set-face-attribute 'mode-line nil :box nil))))
#+end_src

** Emoji

#+begin_src emacs-lisp
  (use-package company-emoji
    :ensure t
    :pin melpa
    :config
    (when (and (display-graphic-p) (eq system-type 'darwin))
      (set-fontset-font "fontset-default" 'unicode "Apple Color Emoji" nil 'prepend)
      (add-to-list 'company-backends 'company-emoji)))
#+end_src

* Features
** company

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :defer t)
#+end_src

** exec-path-from-shell

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :if (memq window-system '(mac ns))
    :ensure t
    :config
    (exec-path-from-shell-copy-env "JAVA_HOME")
    (exec-path-from-shell-copy-env "GOPATH")
    (exec-path-from-shell-initialize))
#+end_src

** flycheck

#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :commands (flycheck-mode global-flycheck-mode))
#+end_src

** fullframe

#+begin_src emacs-lisp
  (use-package fullframe
    :ensure t)
#+end_src

** git-gutter

#+begin_src emacs-lisp
  (use-package git-gutter
    :ensure t
    :config
    (global-git-gutter-mode 1))
#+end_src

** ibuffers

#+begin_src emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . ibuffer)
           ("<C-tab>" . ibuffer))
    :config
    (defvar ibuffer-saved-filter-groups
      (quote (("default"
               ("org" (mode . org-mode))
               ("java" (mode . java-mode))
               ("json" (mode . json-mode))
               ("clojure" (mode . clojure-mode))
               ("python" (mode . python-mode))
               ("web" (or (mode . css-mode)
                          (mode . html-mode)
                          (mode . js-mode)))
               ("erc" (name . "^\\#"))
               ("elisp" (mode . emacs-lisp-mode))
               ("dirs" (mode . dired-mode))
               ("temps" (name . "^\\*.*\\*$"))))))
    (add-hook 'ibuffer-mode-hook
              '(lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default"))))
#+end_src

** ido

Using =ivy= for the moment, but this is my =ido= configuration.

#+begin_src elisp
  ;; (use-package ido
  ;;   :commands ido-mode
  ;;   :config
  ;;   (ido-mode 1)
  ;;   (ido-everywhere 1)
  ;;   (setq ido-enable-flex-matching t))

  ;; (use-package ido-completing-read+
  ;;   :ensure t
  ;;   :defer t
  ;;   :commands ido-ubiquitous-mode
  ;;   :config
  ;;   (ido-ubiquitous-mode 1))

  ;; (use-package flx-ido
  ;;   :ensure t
  ;;   :defer t
  ;;   :config
  ;;   (flx-ido-mode 1)
  ;;   (setq ido-use-faces nil))

  ;; (defvar ido-vertical-define-keys)

  ;; (use-package ido-vertical-mode
  ;;   :ensure t
  ;;   :config
  ;;   (ido-vertical-mode 1)
  ;;   (setq ido-vertical-define-keys 'C-n-C-p-up-and-down))

  ;; (use-package smex
  ;;   :ensure t
  ;;   :defer t
  ;;   :bind (("M-x" . smex)))
#+end_src

** ivy

Completion utility ([[https://oremacs.com/swiper/]]).

#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :config
    (ivy-mode 1)
    (setq ivy-display-style 'fancy)
    (setq ivy-use-virtual-buffers t)
    ;; (setq ivy-count-format "(%d/%d) ")
    (setq ivy-count-format "") ;; "("%d/%d) "
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (setq ivy-use-selectable-prompt t))
  (use-package swiper
    :ensure t
    :after ivy)
  (use-package counsel
    :ensure t
    :config
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "C-h v") 'counsel-describe-variable)
    (global-set-key (kbd "C-h f") 'counsel-describe-function)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    ;; Has to be set here because counsel overrides ivy.
    ;;  - Remove the ^ regex assumption for all searches
    (setq ivy-initial-inputs-alist nil))
  (use-package flx ; used by regex-fuzzy, I think.
    :ensure t)
  (use-package smex ; counsel-M-x will use this?
    :ensure t)
  (use-package ivy-rich
    :ensure t
    :after ivy
    :config
    (ivy-rich-mode 1)
    (setq ivy-rich-path-style 'abbrev))
#+end_src

** multiple-cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands multiple-cursors-mode
    :ensure t
    :pin melpa
    :config
    (setq mac-command-modifier 'super)
    :bind (("C-s-c k" . mc/edit-lines)
           ("C-M->" . mc/mark-all-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C->" . mc/mark-next-like-this)))
#+end_src

** paredit

#+begin_src emacs-lisp
  (use-package paredit
    :ensure t
    :commands paredit-mode)
#+end_src

** paren-face

#+begin_src emacs-lisp
  (use-package paren-face
    :ensure t
    :config
    (global-paren-face-mode 1))
#+end_src

** projectile

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :bind (("s-p" . projectile-find-file)
         ("C-c p" . projectile-find-file))
  :init
  (setq projectile-completion-system 'ivy))
#+end_src

** restclient

https://github.com/pashky/restclient.el
https://github.com/alf/ob-restclient.el
https://github.com/iquiw/company-restclient

#+begin_src emacs-lisp
  (use-package restclient
    :ensure t
    :config
    (add-hook 'restclient-mode-hook (lambda ()
                                      (company-mode 1))))

  (use-package ob-restclient
    :ensure t
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t))))

  (use-package company-restclient
    :ensure t
    :config
    (add-to-list 'company-backends 'company-restclient))
#+end_src

** ripgrep

Control-meta-super-F

#+begin_src emacs-lisp
  (use-package ripgrep
    :ensure t
    :bind (("C-M-s-f" . projectile-ripgrep)))
#+end_src

** treemacs

[[https://github.com/Alexander-Miller/treemacs]]

#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (setq treemacs-width 30)
    (treemacs-resize-icons 16))

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)
#+end_src

** which-key

=which-key= is a minor mode for Emacs that displays the key bindings
following your currently entered incomplete command (a prefix) in a
popup.

[[https://github.com/justbur/emacs-which-key]]

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode 1))
#+end_src

** yasnippet

http://joaotavora.github.io/yasnippet/

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    ;; I can't get this to work as a minor mode, for some reason.
    (yas-global-mode))
#+end_src

* Application Modes
** Directory Editor (Dired)

#+begin_src emacs-lisp
  (use-package dired
    :bind ("C-x C-q" . wdired-change-to-wdired-mode)
    :config
    (defun kfi/dired-mode-hook ()
      (dired-hide-details-mode)
      (when (display-graphic-p)
        (hl-line-mode)))
    (add-hook 'dired-mode-hook 'kfi/dired-mode-hook)
    (when (eq system-type 'darwin)
      (setq trash-directory "~/.Trash")
      (setq delete-by-moving-to-trash t))
    (when (eq system-type 'darwin)
      (setq dired-use-ls-dired nil)))
#+end_src

** Erc (IRC Client)

#+begin_src emacs-lisp
  (use-package erc
    :config
    (defun kfi/erc-mode-hook ()
      (make-local-variable 'global-hl-line-mode)
      (setq global-hl-line-mode nil))

    (add-hook 'erc-mode-hook 'kfi/erc-mode-hook)

    ;; Not sure if this is necessary.
    (add-to-list 'erc-modules 'truncate)
    (add-to-list 'erc-modules 'scrolltobottom)
    (erc-update-modules)

    (erc-scrolltobottom-mode 1)

    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-fill-prefix "    ")
    (setq erc-prompt (lambda () (concat "\n" (buffer-name) " >")))

    (setq erc-fill-column 79)
    (setq erc-scroll-to-bottom -2)
    (setq erc-truncate-buffer-on-save t)
    (setq erc-max-buffer-size 30000)

    (add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t))

  (use-package erc-hl-nicks
    :ensure t)
#+end_src

** Magit (Git Client)

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-c g" . kfi/magit-start-session)
           ("C-c l"  . kfi/magit-log-session)
           :map magit-status-mode-map
           ("q" . kfi/magit-quit-session))
    :config

    (defun kfi/magit-start-session ()
      "Go full screen when invoking magit-status."
      (interactive)
      (window-configuration-to-register :magit-fullscreen)
      (call-interactively 'magit-status)
      (delete-other-windows))

    (defun kfi/magit-log-session ()
      "Go full screen when invoking magit-log."
      (interactive)
      (window-configuration-to-register :magit-fullscreen)
      (call-interactively 'magit-log)
      (delete-other-windows))

    (defun kfi/magit-quit-session ()
      "Quit the magit session and restore windows."
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen)))
#+end_src

** +Multi-Term (Terminal Client -- retired)+

#+begin_src emacs-lisp
  ;; (use-package multi-term
  ;;   :ensure t
  ;;   :commands multi-term
  ;;   :bind (("C-c h" . multi-term))
  ;;   :config
  ;;   (defadvice term-char-mode (after term-char-mode-fixes ())
  ;;     "Causes a compile-log warning."
  ;;     ;; (set (make-local-variable 'hl-line-mode) nil)
  ;;     (set (make-local-variable 'global-hl-line-mode) nil))

  ;;   (ad-activate 'term-char-mode)

  ;;   (setq multi-term-program "/bin/zsh")
  ;;   (set-face-attribute 'term nil :inherit 'default)
  ;;   (set-face-attribute 'term nil :inherit 'default)
  ;;   (set-face-attribute 'term-color-cyan nil :foreground "dodgerblue")
  ;;   (set-face-attribute 'term-color-blue nil :foreground "dodgerblue")
  ;;   (set-face-attribute 'term-color-black nil :foreground "gray50")
  ;;   (set-face-attribute 'term-color-yellow nil :foreground "peru")

  ;;   (add-hook 'term-exec-hook
  ;;             (function
  ;;              (lambda ()
  ;;                (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))

  ;;   (add-hook 'term-mode-hook (lambda ()
  ;;                               (display-line-numbers-mode -1)))
  ;;   (add-hook 'term-mode-hook (lambda ()
  ;;                               (define-key term-raw-map (kbd "C-y") 'term-paste)
  ;;                               (define-key term-raw-map (kbd "C-v") 'term-paste)
  ;;                               (define-key term-raw-map (kbd "s-v") 'term-paste)))
  ;;   (add-hook 'eshell-mode-hook (lambda ()
  ;;                                 (display-line-numbers-mode -1))))
#+end_src

** Persistent Scratch Buffer

#+begin_src emacs-lisp
  (use-package persistent-scratch
    :ensure t
    :config
    (persistent-scratch-setup-default)
    (persistent-scratch-autosave-mode 1))
#+end_src

** VTerm (Terminal Client)

https://github.com/akermu/emacs-libvterm

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :bind (("C-c v" . vterm)
           ("C-c h" . vterm))
    :init (setq vterm-kill-buffer-on-exit t)
    :hook (vterm-mode . (lambda ()
                          (define-key vterm-mode-map (kbd "C-v") 'vterm-yank)
                          (define-key vterm-mode-map (kbd "s-v") 'vterm-yank)))
    :config
    (when (display-graphic-p)
      ;; pastel
      (set-face-attribute 'vterm-color-default nil :foreground "#c7c7c7")
      (set-face-attribute 'vterm-color-cyan nil :foreground "#d0d3fd")
      (set-face-attribute 'vterm-color-blue nil :foreground "#a8d6fd")
      (set-face-attribute 'vterm-color-black nil :foreground "#626262")
      (set-face-attribute 'vterm-color-yellow nil :foreground "#fffcc0")
      (set-face-attribute 'vterm-color-green nil :foreground "#b9f87b")
      (set-face-attribute 'vterm-color-white nil :foreground "#f1f1f2")))
#+end_src

* Configuration Modes
** Dockerfile Mode

#+begin_src emacs-lisp
  (use-package dockerfile-mode
    :commands dockerfile-mode
    :ensure t
    :defer t)
#+end_src

* Document Modes
** CSS Mode

#+begin_src emacs-lisp
  (use-package css-mode
    :commands css-mode
    :init
    (defun kfi/css-setup ()
      (company-mode 1)
      ;; (set (make-local-variable 'company-backends) '(company-css))
      ;; (turn-on-css-eldoc)
      (setq css-indent-offset 2)
      (local-set-key (kbd "TAB") 'company-complete)
      (local-set-key (kbd "RET") 'newline-and-indent))

    (add-hook 'css-mode-hook 'kfi/css-setup))

  (use-package css-eldoc
    :ensure t
    :defer t)
#+end_src

** HTML Mode

#+begin_src emacs-lisp
  (use-package html-mode
    :commands html-mode
    :init
    (add-hook 'html-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** JSON Mode

#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :commands json-mode
    :init
    (add-hook 'js-mode-hook (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq js-indent-level 2)
                              (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** Markdown Mode

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("readme\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (("s-b" . markdown-insert-bold)
           ("s-i" . markdown-insert-italic)
           ("s-k" . kfi/markdown-insert-small))
    :config
    ;; Cut/paste from markdown-mode.el
    (defun kfi/markdown-insert-small ()
      (interactive)
      (if (markdown-use-region-p)
          ;; Active region
          (let ((bounds (markdown-unwrap-things-in-region
                         (region-beginning) (region-end)
                         markdown-regex-code 1 3)))
            (markdown-wrap-or-insert
             "<small>" "</small>" nil (car bounds) (cdr bounds)))
        (if (markdown-inline-code-at-point)
            (markdown-unwrap-thing-at-point nil 0 2)
          (markdown-wrap-or-insert "<small>" "</small>" 'word nil nil))))
    ;;
    (add-hook 'markdown-mode-hook 'turn-on-flyspell)
    (add-hook 'markdown-mode-hook (lambda ()
                                    (auto-fill-mode 1))))
#+end_src

** Org Mode

Provide "pretty" bullets for =Org Mode=.

#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t
    :after org)
#+end_src

I've configured the =Org Mode= to use hard line-breaks for paragraphs at
70 characters (rather than using visual-line mode) so that an =org=
document will be readable (except for tags) at the command line.

Turn off indentation, pretty bullets and so on when running in
terminal mode because it just makes things even uglier for those few
times you need it.

#+begin_src emacs-lisp
  (use-package org
    :ensure t
    :pin org
    :config
    (setq org-ellipsis " … "
          org-fontify-done-headline t
          org-agenda-start-on-weekday 0
          org-hide-emphasis-markers t
          org-src-window-setup 'split-window-below
          org-support-shift-select t
          org-src-tab-acts-natively t
          org-src-window-setup 'current-window)

    (defun kfi/org-align-tags ()
      "Align tags to their columns."
      (interactive)
      (org-align-tags t))

    (defun kfi/org-toggle-markers ()
      "Toggle showing markup markers (italics, bold, etc)."
      (interactive)
      (org-toggle-link-display))

    (defun kfi/org-keys-setup ()
      (define-key org-mode-map (kbd "<f1>") 'org-tree-to-indirect-buffer)
      (define-key org-mode-map (kbd "<s-escape>") 'org-tree-to-indirect-buffer)
      (define-key org-mode-map (kbd "C-c a") 'org-agenda)
      (define-key org-mode-map (kbd "C-c t") 'kfi/org-align-tags))

    (defun kfi/org-graphic-mode-setup ()
      (when (display-graphic-p)
        ;; Have to set this so that I can adjust it when switching to
        ;; the theme.
        (buffer-face-set 'org-default)
        (org-indent-mode 1)
        (org-bullets-mode 1)
        (setq-local global-hl-line-mode nil)))

    (defun kfi/org-standard-setup ()
      (auto-fill-mode 1)
      (yas-minor-mode-on))

    ;; Is this necessary? I have a vague memory that this
    ;; helps with org exports to HTML.
    (use-package htmlize
      :ensure t)

    (add-hook 'org-mode-hook 'kfi/org-graphic-mode-setup)
    (add-hook 'org-mode-hook 'kfi/org-keys-setup)
    (add-hook 'org-mode-hook 'kfi/org-standard-setup))
#+end_src

** Web Mode

Facilitates a web page with CSS, Javascript and HTML mixed together.

#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :commands web-mode
    :mode (("\\.html?\\'" . web-mode))
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-content-types (cons '("jsx" . "\\.js\\'") web-mode-content-types))
    (set-face-attribute 'web-mode-html-tag-face nil :foreground "cornflowerblue")
    (set-face-attribute 'web-mode-html-tag-bracket-face nil :foreground "goldenrod"))
#+end_src

** YAML Mode

#+begin_src emacs-lisp
  (use-package yaml-mode
    :commands yaml-mode
    :ensure t)
#+end_src

* Programming Modes
** Clojure Mode

This needs to be revisited if I start using Clojure again.

#+begin_src emacs-lisp
  (use-package cider
    :ensure t
    :after company
    :config
    (setq cider-font-lock-dynamically '(macro core function var))
    (setq cider-eldoc-display-context-dependent-info t)
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-use-pretty-printing t)
    (setq cider-repl-wrap-history t)
    (setq cider-repl-history-size 3000)
    (setq cider-repl-display-help-banner nil)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode))

  (use-package clojure-mode-extra-font-locking
    :ensure t)

  (use-package clojure-mode
    :commands clojure-mode
    :ensure t
    :delight "clj"
    :config
    (put-clojure-indent 'Conditional 1)
    (put-clojure-indent 'ControlBar 0)
    (put-clojure-indent 'DisplayBlock 1)
    (put-clojure-indent 'Container 2)
    (put-clojure-indent 'IncludeIf 0)
    (put-clojure-indent 'Table 1)
    (put-clojure-indent 'protobuf 1)
    (put-clojure-indent 'POST 2)
    (put-clojure-indent 'GET 2)
    (add-hook 'clojure-mode-hook 'prettify-symbols-mode)
    (add-hook 'clojure-mode-hook 'paredit-mode)
    (add-hook 'clojure-mode-hook 'cider-mode)
    (setq clojure-indent-style nil))
#+end_src

** Emacs Lisp Mode

#+begin_src emacs-lisp
  (use-package emacs
    :ensure t
    :init
    (defun kfi/emacs-lisp-mode-setup ()
      (paredit-mode 1)
      (setq indent-tabs-mode nil)
      (local-set-key (kbd "RET") 'newline-and-indent)
      (company-mode 1)
      (when (display-graphic-p)
        (hl-line-mode 1)))
    (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
    (add-hook 'emacs-lisp-mode-hook 'kfi/emacs-lisp-mode-setup))
#+end_src

** Go Mode

Revisit if I use Go again.

#+begin_src emacs-lisp
  (use-package flycheck-gometalinter
    :ensure t
    :config
    (flycheck-gometalinter-setup))

  (use-package go-eldoc
    :ensure t)

  (use-package go-mode
    :ensure t
    :commands go-mode
    :init
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'go-mode-hook 'flycheck-mode)
    :config
    (setq gofmt-command "goimports"))

  (use-package golint
    :ensure t)
#+end_src

** Groovy Mode

#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t
    :defer t
    :mode (("\\.groovy" . groovy-mode)
           ("\\.gradle" . groovy-mode)))
#+end_src

** Java Mode

- [[https://github.com/emacs-lsp/lsp-ui]]

TODO: Check out this config [[https://github.com/hlissner/doom-emacs-private/blob/master/config.el][hlissner's config.el]] to see how I might
customize lsp so it's not so facey.

#+begin_src emacs-lisp
  (use-package cc-mode
    :init
    (add-hook 'java-mode-hook (lambda ()
                                (hl-line-mode t)
                                (display-line-numbers-mode 1)
                                (setq c-basic-offset 4)
                                (setq tab-width 4)
                                (setq indent-tabs-mode nil))))

  (use-package lsp-mode
    :ensure t)

  (use-package hydra
    :ensure t)

  (use-package company-lsp
    :ensure t)

  (use-package lsp-ui
    :ensure t
    :config
    ;; If the popups get too tiresome, use this:
    (setq lsp-auto-configure nil))

  (use-package lsp-java
    :ensure t
    :after lsp
    :config (add-hook 'java-mode-hook (lambda ()
                                        (company-mode)
                                        (lsp)
                                        (flycheck-mode 1))))

  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config (progn (dap-mode t)
                   (dap-ui-mode t)))
#+end_src

** Javascript Mode

#+begin_src emacs-lisp
  (use-package js-mode
    :commands js-mode
    :init
    (add-hook 'js-mode-hook (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq js-indent-level 2)
                              (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** Python Mode

#+begin_src emacs-lisp
  ;; (use-package elpy
  ;;   :ensure t
  ;;   :defer t
  ;;   :init
  ;;   (advice-add 'python-mode :before 'elpy-enable))

  ;; (use-package py-autopep8
  ;;   :ensure t
  ;;   :defer t
  ;;   :init
  ;;   (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
  ;;   (setq flycheck-python-pycompile- executable "python3"))

  (use-package lsp-python-ms
    :ensure t
    :hook (python-mode . (lambda ()
                           (require 'lsp-python-ms)
                           (lsp))))
#+end_src

** Swift Mode

#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t
    :defer t
    :config
    (defun kfi/swift-mode ()
      ;;(lsp) ;; I don't think this works for XCode projects.
      (setq swift-mode:basic-offset 4)
      (setq indent-tabs-mode nil)
      (hl-line-mode 1)
      (company-mode 1))
    (add-hook 'swift-mode-hook 'kfi/swift-mode))
#+end_src

See if =lsp-sourcekit= is a pleasant diversion from Xcode.

#+begin_src emacs-lisp
  (use-package lsp-sourcekit
    :after lsp-mode
    :ensure t
    :config
    (setenv "SOURCEKIT_TOOLCHAIN_PATH" "/Library/Developer/Toolchains/swift-latest.xctoolchain")
    ;; xcrun --find sourcekit-lsp
    (setq lsp-sourcekit-executable (expand-file-name "/Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/bin/sourcekit-lsp")))
#+end_src

I don't think this works too well if you point it at a random Xcode
based project. I get a lot of errors like:

#+begin_quote
could not find manifest, or not a SwiftPM package: /Path/To/Xcode/Project
#+end_quote

So, this is a no go for the time being.

* Settings
** Default directory

#+begin_src emacs-lisp
  (setq default-directory "~/")
#+end_src

** Hollow cursor

#+begin_src emacs-lisp
  (set-default 'cursor-type 'hollow)
#+end_src

** Global auto revert files (load if changed on disk)

Global Auto Revert mode is a global minor mode that reverts any buffer
associated with a file when the file changes on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

** Truncate lines

Do not wrap lines when they're too long.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

** Electric parens

Toggle automatic parens pairing (Electric Pair mode).

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

** Replace selected text when you type something

When Delete Selection mode is enabled, typed text replaces the
selection if the selection is active. Otherwise, typed text is just
inserted at point regardless of any selection.

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

** Show column numbers in the mode line

Toggle column number display in the mode line (Column Number mode).

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

** Use regular keys for cut/copy/paste (cua-mode)

CUA mode is a global minor mode. When enabled, typed text replaces the
active selection, and you can use C-z, C-x, C-c, and C-v to undo, cut,
copy, and paste in addition to the normal Emacs bindings. The C-x and
C-c keys only do cut and copy when the region is active, so in most
cases, they do not conflict with the normal function of these prefix
keys.

#+begin_src emacs-lisp
  (cua-mode 1)
#+end_src

** Show matching parens

Toggle visualization of matching parens (Show Paren mode).

#+begin_src emacs-lisp
  (show-paren-mode t)
#+end_src

** Font resizing keyboard bindings

Mimics normal Mac keybindings for font resizing.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-+") 'text-scale-increase)
  (global-set-key (kbd "s-_") 'text-scale-decrease)
#+end_src

** Window navigation keyboard commands

#+begin_src emacs-lisp
  (global-set-key (kbd "M-`") 'other-frame)
  (global-set-key (kbd "s-<right>") 'windmove-right)
  (global-set-key (kbd "s-<left>") 'windmove-left)
  (global-set-key (kbd "s-<up>") 'windmove-up)
  (global-set-key (kbd "s-<down>") 'windmove-down)

  (defun kfi/goto-scratch ()
    "Switch (or create) the *scratch* buffer."
    (interactive)
    (switch-to-buffer (get-buffer-create "*scratch*"))
    (lisp-interaction-mode))

  (global-set-key (kbd "s-0") 'delete-window)
  (global-set-key (kbd "s-1") 'delete-other-windows)
  (global-set-key (kbd "s-2") 'split-window-below)
  (global-set-key (kbd "s-3") 'split-window-right)
  (global-set-key (kbd "s-9") 'kfi/goto-scratch)
#+end_src

** Window placement

Rules:

 - Terminal windows appear at the bottom.
 - Help windows appear docked on the left.

#+begin_src emacs-lisp
  (use-package emacs
    :hook ((help-mode . visual-line-mode))
    :init
    (setq display-buffer-alist
          '(("\\*Help.*"
             (display-buffer-in-side-window)
             (window-parameters . ( ;;(no-other-window . t)
                                   (mode-line-format . (" " mode-line-buffer-identification))))
             (window-width . 0.5)
             (side . left)
             (slot . 0))
            ("\\*eshell.*"
             (display-buffer-in-side-window)
             (window-parameters . ((mode-line-format . (" " mode-line-buffer-identification))))
             (window-height . 0.2)
             (side . bottom)
             (slot . 0)))))
#+end_src

** Uncategorized

#+begin_src emacs-lisp
    ;; banish custom config to another file
    (setq custom-file "~/.emacs.d/custom.el")

    ;; UTF0-8 (still necessary?)
    (prefer-coding-system 'utf-8)
    (when (display-graphic-p)
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))

    ;; Don't require spelling out yes or no.
    (fset 'yes-or-no-p 'y-or-n-p)

    (setq make-backup-files nil)
    (setq auto-save-default nil)

    (if (display-graphic-p)
        (progn (scroll-bar-mode 0)
               (fringe-mode '(10 . 10)))
      (progn (menu-bar-mode 0)))

    (setq ns-use-mwheel-momentum nil)
    (pixel-scroll-mode 0)

    (custom-set-variables '(indent-tabs-mode nil))
    (setq-default line-spacing 1)
    (setq-default inhibit-startup-screen t)
    (setq-default standard-indent 2)
    (setq-default tab-width 2)
    (add-hook 'before-save-hook 'whitespace-cleanup)
    (blink-cursor-mode 0)
    (setq ring-bell-function 'ignore)

    ;; Set the frame title to the visited file's path
    ;; using the abbreviated form (~ for home).
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b"))))

    (setq mac-command-modifier 'super)

    ;; Quick access to shell
    (global-set-key (kbd "C-c e") 'eshell)

    (setq ns-use-srgb-colorspace t)
#+end_src

* Custom Functions
** Sort lines (nocase)

#+begin_src emacs-lisp
  (defun kfi/sort-lines-nocase ()
    "Sort lines ignoring case"
    (interactive)
    (let ((sort-fold-case t))
      (call-interactively 'sort-lines)))
#+end_src

** Insert timestamp

What I use when I can't use [[https://www.keyboardmaestro.com/main/][Keyboard Maestro]]. Each of the formats
could be made into a =yasnippet= (which is what I do with KB Maestro)
using an elisp expression as its body. But I like the ~completing-read~
minibuffer menu thing here.

#+begin_src emacs-lisp
  (defvar kfi/timestamp-formats
    '(("March 15, 2020 @ 9:33 PM" . "%B %-d, %Y @ %-I:%M %p")
      ("March 15, 2020"           . "%B %-d, %Y")
      ("2020-03-15T21:33:54"      . "%Y-%m-%dT%H:%M:%S")
      ("2020-03-15"               . "%Y-%m-%d")
      ("2020-03-15 09:35 PM"      . "%Y-%m-%d %I:%M %p")
      ("2020-03-15T21:39:20-0700" . "%FT%T%z"))
    "Formats for inserting a timestamp into a document.")

  (defun kfi/timestamp ()
    "Choose a format, then insert a timestamp."
    (interactive)
    (if-let* ((choices (mapcar #'car kfi/timestamp-formats))
              (choice (completing-read "Format:" choices))
              (format (cdr (assoc choice kfi/timestamp-formats))))
        (insert (format-time-string format))
      (insert "<error:nil-selection>")))
#+end_src

** Remove smart quotes from a buffer

#+begin_src emacs-lisp
  (defun kfi/unsmart ()
    "Remove smart quotes from buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "’" nil t)
        (replace-match "'"))
      (goto-char (point-min))
      (while (re-search-forward "”" nil t)
        (replace-match "\""))
      (goto-char (point-min))
      (while (re-search-forward "“" nil t)
        (replace-match "\""))))
#+end_src

** Remove newlines until end of paragraph @bug

Actually, this doesn't do what I think it does: it seems to go to the
stop of the buffer, when it should instead find the beginning of the
paragraph. I wonder what the original intent was?

#+begin_src emacs-lisp
  (defun kfi/unwrap-line ()
    "Remove newlines until end-of-paragraph."
    (interactive)
    (let ((start (point-min))
          (end (copy-marker (or (search-forward "\n\n" nil t)
                                (point-max))))
          (fill-column (point-max)))
      (fill-region start end)
      (goto-char end)
      (newline)
      (goto-char start)))
#+end_src

** Set frame sizing functions

#+begin_src emacs-lisp
  (defun kfi/set-frame-width (arg)
    "Set the width of the frame to ARG."
    (interactive "nFrame width: ")
    (set-frame-width (selected-frame) arg))

  (defun kfi/dw ()
    "Set frame to double-wide."
    (interactive)
    (kfi/set-frame-width 180))

  (defun kfi/sw ()
    "Set frame to single-wide."
    (interactive)
    (kfi/set-frame-width 90))

  (global-set-key (kbd "C-c C-x w") 'kfi/dw)
  (global-set-key (kbd "C-c C-x s") 'kfi/sw)

  (defun kfi/set-frame-height (arg)
    "Set frame height to ARG."
    (interactive "nFrame height: ")
    (set-frame-height (selected-frame) arg))

  (defun kfi/set-frame-dimensions (w h)
    "Set frame dimensions to W and H."
    (interactive "nFrame width: \nnFrame height: ")
    (set-frame-width (selected-frame) w)
    (set-frame-height (selected-frame) h))
#+end_src

** Go back to the previous window

#+begin_src emacs-lisp
  (defun kfi/back-window ()
    "Go back to previously visited window."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x p") 'kfi/back-window)
#+end_src

** Open the current file in whatever MacOS thinks is the appropriate handler

#+begin_src emacs-lisp
  (defun kfi/open-this ()
    "Open the buffer using MacOS defaults."
    (interactive)
    (shell-command (concat "open '" (buffer-file-name) "'")))

  (global-set-key (kbd "C-c C-x o") 'kfi/open-this)

#+end_src

** Adjust font size up or down

#+begin_src emacs-lisp
  (defun kfi/set-font-size (size)
    "Set the font SIZE."
    (interactive "nNew size: ")
    (set-face-attribute 'default nil :height size))

  (defun kfi/font-size-up ()
    "Shift font size up by 10 units."
    (interactive)
    (kfi/set-font-size (+ (face-attribute 'default :height) 10)))

  (defun kfi/font-size-down ()
    "Shift font size down by 10 units."
    (interactive)
    (kfi/set-font-size (- (face-attribute 'default :height) 10)))
#+end_src

** Generate some lorem ipsum text

#+begin_src emacs-lisp
  (defun kfi/lorem ()
    "Output a bunch of lorem ipsum text."
    (interactive)
    (insert
     "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
     "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
     "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
     "aliquip ex ea commodo consequat. Duis aute irure dolor in "
     "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
     "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
     "culpa qui officia deserunt mollit anim id est laborum."))
#+end_src

** Sort the words in the current selection

#+begin_src emacs-lisp
  (defun kfi/sort-words (reverse beg end)
    "Sort region words REVERSE if negative from BEG to END.
  Prefixed with negative \\[universal-argument], sorts in reverse.
  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src

** Make the background (and foreground) slightly transparent (or not)

#+begin_src emacs-lisp
  (defun kfi/transparency-on ()
    "Turn on frame transparency."
    (interactive)
    (set-frame-parameter nil 'alpha '(95 95))
    (add-to-list 'default-frame-alist '(alpha 95 95)))

  (defun kfi/transparency-no ()
    "Turn off frame transparency."
    (interactive)
    (set-frame-parameter nil 'alpha '(100 100))
    (add-to-list 'default-frame-alist '(alpha 100 100)))
#+end_src

** Visit Emacs' init.el file

#+begin_src emacs-lisp
  (defun kfi/edit-init-el ()
    "Visit the init.el file."
    (interactive)
    (find-file "~/.emacs.d/init.el"))
#+end_src

** Visit configuration.org for Emacs

#+begin_src emacs-lisp
  (defun kfi/my-config ()
    "Visit my configuration.org file for Emacs."
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))
#+end_src

* Futures

** Find a way for fly-spell to not check certain words

Do something like the following, and have that function check for
words beginning and ending with "=" or "@" or "#" or "~".

#+begin_src block
  (add-hook 'java-mode-hook
            (lambda ()
              (setq flyspell-generic-check-word-predicate 'my-new-function)))
#+end_src

Also check: https://emacs.stackexchange.com/a/31302 for using faces to
avoid spellchecking in comments, though I'm not sure this will work in
org-mode given it's not a programming mode. Hm.

#+begin_src block
  (setq flyspell-prog-text-faces
        (delq 'font-lock-string-face
              flyspell-prog-text-faces))
#+end_src

* Advice

** How do you add words to the spell check local dictionary?

Try =M-$=, then =i= then =yes= to accept the word. Maybe sure the word is
highlighted.

To double check your learned words, look in =~/.aspell.pws=.

** Where does Flyspell put your "learned" words?

Look in =~/.aspell.pws=.

** How do I fix issues with lsp-java always wanting to rename packages?

Quit emacs, then go into =~/.emacs.d= and remove the workspace
directory. When you restart, things should be better.

Also, visit build.gradle and run ~M-x
lsp-java-update-project-configuration~, and make ~lsp-restart-workspace~.

** How do I add a new project to Treemacs without triggering "project already exists"?

When you enter in the path to the new project for your workspace,
remove the trailing ~/~ from the path.
