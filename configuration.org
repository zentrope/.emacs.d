#+title: Emacs Configuration
#+startup: overview

* Packages
** company

#+begin_src emacs-lisp
  (use-package company
    :ensure t
    :defer t)
#+end_src

** ibuffers

#+begin_src emacs-lisp
  (use-package ibuffer
    :bind (("C-x C-b" . ibuffer)
           ("<C-tab>" . ibuffer))
    :config
    (defvar ibuffer-saved-filter-groups
      (quote (("default"
               ("org" (mode . org-mode))
               ("java" (mode . java-mode))
               ("json" (mode . json-mode))
               ("clojure" (mode . clojure-mode))
               ("python" (mode . python-mode))
               ("web" (or (mode . css-mode)
                          (mode . html-mode)
                          (mode . js-mode)))
               ("erc" (name . "^\\#"))
               ("elisp" (mode . emacs-lisp-mode))
               ("dirs" (mode . dired-mode))
               ("temps" (name . "^\\*.*\\*$"))))))
    (add-hook 'ibuffer-mode-hook
              '(lambda ()
                 (ibuffer-switch-to-saved-filter-groups "default"))))
#+end_src

** ido

Using =ivy= for the moment, but this is my =ido= configuration.

#+begin_src elisp
  ;; (use-package ido
  ;;   :commands ido-mode
  ;;   :config
  ;;   (ido-mode 1)
  ;;   (ido-everywhere 1)
  ;;   (setq ido-enable-flex-matching t))

  ;; (use-package ido-completing-read+
  ;;   :ensure t
  ;;   :defer t
  ;;   :commands ido-ubiquitous-mode
  ;;   :config
  ;;   (ido-ubiquitous-mode 1))

  ;; (use-package flx-ido
  ;;   :ensure t
  ;;   :defer t
  ;;   :config
  ;;   (flx-ido-mode 1)
  ;;   (setq ido-use-faces nil))

  ;; (defvar ido-vertical-define-keys)

  ;; (use-package ido-vertical-mode
  ;;   :ensure t
  ;;   :config
  ;;   (ido-vertical-mode 1)
  ;;   (setq ido-vertical-define-keys 'C-n-C-p-up-and-down))

  ;; (use-package smex
  ;;   :ensure t
  ;;   :defer t
  ;;   :bind (("M-x" . smex)))
#+end_src

** ivy

Completion utility ([[https://oremacs.com/swiper/]]).
- https://github.com/tumashu/ivy-posframe

#+begin_src emacs-lisp
  (use-package ivy
    :ensure t
    :config
    (ivy-mode 1)
    (setq ivy-display-style 'fancy)
    (setq ivy-use-virtual-buffers t)
    ;; (setq ivy-count-format "(%d/%d) ")
    (setq ivy-count-format "") ;; "("%d/%d) "
    (setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    (setq ivy-use-selectable-prompt t))
  (use-package swiper
    :ensure t
    :after ivy)
  (use-package counsel
    :ensure t
    :config
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "C-h v") 'counsel-describe-variable)
    (global-set-key (kbd "C-h f") 'counsel-describe-function)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    ;; Has to be set here because counsel overrides ivy.
    ;;  - Remove the ^ regex assumption for all searches
    (setq ivy-initial-inputs-alist nil))
  (use-package flx ; used by regex-fuzzy, I think.
    :ensure t)
  (use-package ivy-rich
    :ensure t
    :after ivy
    :config
    (ivy-rich-mode 1)
    (setq ivy-rich-path-style 'abbrev))
  (use-package ivy-posframe
    :ensure t
    :config
    (setq ivy-posframe-display-functions-alist
          '((t . ivy-posframe-display-at-frame-center)))
    (setq ivy-posframe-parameters
          '((left-fringe . 8)
            (right-fringe . 8)))
    (ivy-posframe-mode 1))
#+end_src

** multiple-cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors
    :commands multiple-cursors-mode
    :ensure t
    :pin melpa
    :config
    (setq mac-command-modifier 'super)
    :bind (("C-S-c k" . mc/edit-lines)
           ("C-M->" . mc/mark-all-like-this)
           ("C-<" . mc/mark-previous-like-this)
           ("C->" . mc/mark-next-like-this)))
#+end_src

** projectile

#+begin_src emacs-lisp
(use-package projectile
  :ensure t
  :bind (("s-p" . projectile-find-file)
         ("C-c p" . projectile-find-file))
  :init
  (setq projectile-completion-system 'ivy))
#+end_src

** restclient

https://github.com/pashky/restclient.el
https://github.com/alf/ob-restclient.el
https://github.com/iquiw/company-restclient

#+begin_src emacs-lisp
  (use-package restclient
    :ensure t
    :config
    (add-hook 'restclient-mode-hook (lambda ()
                                      (company-mode 1))))

  (use-package ob-restclient
    :ensure t
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t))))

  (use-package company-restclient
    :ensure t
    :config
    (add-to-list 'company-backends 'company-restclient))
#+end_src

** treemacs

[[https://github.com/Alexander-Miller/treemacs]]

#+begin_src emacs-lisp
  (use-package treemacs
    :ensure t
    :defer t
    :config
    (setq treemacs-width 30)
    (treemacs-resize-icons 16))

  (use-package treemacs-projectile
    :after treemacs projectile
    :ensure t)
#+end_src

** which-key

=which-key= is a minor mode for Emacs that displays the key bindings following your currently entered incomplete command (a prefix) in a popup.

[[https://github.com/justbur/emacs-which-key]]

#+begin_src emacs-lisp
  (use-package which-key
    :ensure t
    :init (which-key-mode 1))
#+end_src

** yasnippet

http://joaotavora.github.io/yasnippet/

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :init
    ;; I can't get this to work as a minor mode, for some reason.
    (yas-global-mode))
#+end_src

* Appearance
** All the icons

#+begin_src emacs-lisp
(use-package all-the-icons
  :ensure t)
#+end_src

** Doom themes

[[https://github.com/hlissner/emacs-doom-themes]]

#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (load-theme 'doom-acario-light t)
    (set-face-attribute 'default nil :family "JetBrains Mono" :height 140 :weight 'normal)
    (setq doom-themes-treemacs-theme "doom-colors")
    (doom-themes-treemacs-config)
    (doom-themes-org-config))
#+end_src

** Doom modeline

[[https://github.com/seagle0128/doom-modeline]]

#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1))
#+end_src

* Application Modes
** Erc (IRC Client)

#+begin_src emacs-lisp
  (use-package erc
    :config
    (defun kfi/erc-mode-hook ()
      (make-local-variable 'global-hl-line-mode)
      (setq global-hl-line-mode nil))

    (add-hook 'erc-mode-hook 'kfi/erc-mode-hook)

    ;; Not sure if this is necessary.
    (add-to-list 'erc-modules 'truncate)
    (add-to-list 'erc-modules 'scrolltobottom)
    (erc-update-modules)

    (erc-scrolltobottom-mode 1)

    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-fill-prefix "    ")
    (setq erc-prompt (lambda () (concat "\n" (buffer-name) " >")))

    (setq erc-fill-column 79)
    (setq erc-scroll-to-bottom -2)
    (setq erc-truncate-buffer-on-save t)
    (setq erc-max-buffer-size 30000)

    (add-hook 'erc-insert-post-hook 'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t))

  (use-package erc-hl-nicks
    :ensure t)
#+end_src

** Magit (Git Client)

#+begin_src emacs-lisp
  (use-package magit
    :ensure t
    :bind (("C-c g" . kfi/magit-start-session)
           ("C-c l"  . kfi/magit-log-session)
           :map magit-status-mode-map
           ("q" . kfi/magit-quit-session))
    :config

    (defun kfi/magit-start-session ()
      "Go full screen when invoking magit-status."
      (interactive)
      (window-configuration-to-register :magit-fullscreen)
      (call-interactively 'magit-status)
      (delete-other-windows))

    (defun kfi/magit-log-session ()
      "Go full screen when invoking magit-log."
      (interactive)
      (window-configuration-to-register :magit-fullscreen)
      (call-interactively 'magit-log)
      (delete-other-windows))

    (defun kfi/magit-quit-session ()
      "Quit the magit session and restore windows."
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen)))
#+end_src

** Multi-Term (Terminal Client -- retired)

#+begin_src emacs-lisp
  ;; (use-package multi-term
  ;;   :ensure t
  ;;   :commands multi-term
  ;;   :bind (("C-c h" . multi-term))
  ;;   :config
  ;;   (defadvice term-char-mode (after term-char-mode-fixes ())
  ;;     "Causes a compile-log warning."
  ;;     ;; (set (make-local-variable 'hl-line-mode) nil)
  ;;     (set (make-local-variable 'global-hl-line-mode) nil))

  ;;   (ad-activate 'term-char-mode)

  ;;   (setq multi-term-program "/bin/zsh")
  ;;   (set-face-attribute 'term nil :inherit 'default)
  ;;   (set-face-attribute 'term nil :inherit 'default)
  ;;   (set-face-attribute 'term-color-cyan nil :foreground "dodgerblue")
  ;;   (set-face-attribute 'term-color-blue nil :foreground "dodgerblue")
  ;;   (set-face-attribute 'term-color-black nil :foreground "gray50")
  ;;   (set-face-attribute 'term-color-yellow nil :foreground "peru")

  ;;   (add-hook 'term-exec-hook
  ;;             (function
  ;;              (lambda ()
  ;;                (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))

  ;;   (add-hook 'term-mode-hook (lambda ()
  ;;                               (display-line-numbers-mode -1)))
  ;;   (add-hook 'term-mode-hook (lambda ()
  ;;                               (define-key term-raw-map (kbd "C-y") 'term-paste)
  ;;                               (define-key term-raw-map (kbd "C-v") 'term-paste)
  ;;                               (define-key term-raw-map (kbd "s-v") 'term-paste)))
  ;;   (add-hook 'eshell-mode-hook (lambda ()
  ;;                                 (display-line-numbers-mode -1))))
#+end_src

** VTerm (Terminal Client)

https://github.com/akermu/emacs-libvterm

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t
    :bind (("C-c v" . vterm)
           ("C-c h" . vterm))
    :init (setq vterm-kill-buffer-on-exit t)
    :hook (vterm-mode . (lambda ()
                          (define-key vterm-mode-map (kbd "C-v") 'vterm-yank)
                          (define-key vterm-mode-map (kbd "s-v") 'vterm-yank)))
    :config
    (set-face-attribute 'vterm-color-cyan nil :foreground "dodgerblue")
    (set-face-attribute 'vterm-color-blue nil :foreground "dodgerblue")
    (set-face-attribute 'vterm-color-black nil :foreground "gray50")
    (set-face-attribute 'vterm-color-yellow nil :foreground "peru"))
#+end_src

* Document Modes
** CSS Mode

#+begin_src emacs-lisp
  (use-package css-mode
    :commands css-mode
    :init
    (defun kfi/css-setup ()
      (company-mode 1)
      ;; (set (make-local-variable 'company-backends) '(company-css))
      ;; (turn-on-css-eldoc)
      (setq css-indent-offset 2)
      (local-set-key (kbd "TAB") 'company-complete)
      (local-set-key (kbd "RET") 'newline-and-indent))

    (add-hook 'css-mode-hook 'kfi/css-setup))

  (use-package css-eldoc
    :ensure t
    :defer t)
#+end_src

** HTML Mode

#+begin_src emacs-lisp
  (use-package html-mode
    :commands html-mode
    :init
    (add-hook 'html-mode-hook
              (lambda ()
                (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** JSON Mode

#+begin_src emacs-lisp
  (use-package json-mode
    :ensure t
    :commands json-mode
    :init
    (add-hook 'js-mode-hook (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq js-indent-level 2)
                              (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** Markdown Mode

#+begin_src emacs-lisp
  (use-package markdown-mode
    :ensure t
    :commands (markdown-mode gfm-mode)
    :mode (("README\\.md\\'" . gfm-mode)
           ("readme\\.md\\'" . gfm-mode)
           ("\\.md\\'" . markdown-mode)
           ("\\.markdown\\'" . markdown-mode))
    :bind (("s-b" . markdown-insert-bold)
           ("s-i" . markdown-insert-italic)
           ("s-k" . kfi/markdown-insert-small))
    :config
    ;; Cut/paste from markdown-mode.el
    (defun kfi/markdown-insert-small ()
      (interactive)
      (if (markdown-use-region-p)
          ;; Active region
          (let ((bounds (markdown-unwrap-things-in-region
                         (region-beginning) (region-end)
                         markdown-regex-code 1 3)))
            (markdown-wrap-or-insert
             "<small>" "</small>" nil (car bounds) (cdr bounds)))
        (if (markdown-inline-code-at-point)
            (markdown-unwrap-thing-at-point nil 0 2)
          (markdown-wrap-or-insert "<small>" "</small>" 'word nil nil))))
    ;;
    (add-hook 'markdown-mode-hook 'turn-on-flyspell)
    (add-hook 'markdown-mode-hook (lambda ()
                                    (auto-fill-mode 1))))
#+end_src

** Org Mode

#+begin_src emacs-lisp
  (use-package org-bullets
    :ensure t)

  (use-package visual-fill-column
    :ensure t)

  (use-package org
    :ensure t
    :after yasnippet
    :init
    :config
    (setq org-ellipsis " … "
          org-src-window-setup 'split-window-right
          org-tags-column 85)

    (defun kfi/org-align-tags ()
      (interactive)
      (org-align-tags t))

    (defun kfi/org-keys-setup ()
      (define-key org-mode-map (kbd "C-c a") 'org-agenda)
      (define-key org-mode-map (kbd "C-c t") 'kfi/org-align-tags))

    (defun kfi/org-setup ()
      (visual-line-mode 1)
      (visual-fill-column-mode 1)
      (org-bullets-mode 1)
      (org-indent-mode 1)
      (set-fill-column 100)
      (setq-local global-hl-line-mode nil)
      (yas-minor-mode-on))

    (add-hook 'org-mode-hook 'kfi/org-keys-setup)
    (add-hook 'org-mode-hook 'kfi/org-setup))
#+end_src

** Web Mode

Facilitates a web page with CSS, Javascript and HTML mixed together.

#+begin_src emacs-lisp
  (use-package web-mode
    :ensure t
    :commands web-mode
    :mode (("\\.html?\\'" . web-mode))
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-content-types (cons '("jsx" . "\\.js\\'") web-mode-content-types))
    (set-face-attribute 'web-mode-html-tag-face nil :foreground "cornflowerblue")
    (set-face-attribute 'web-mode-html-tag-bracket-face nil :foreground "goldenrod"))
#+end_src

** YAML Mode

#+begin_src emacs-lisp
  (use-package yaml-mode
    :commands yaml-mode
    :ensure t)
#+end_src

* Programming Modes
** Clojure Mode

This needs to be revisited if I start using Clojure again.

#+begin_src emacs-lisp
  (use-package cider
    :ensure t
    :after company
    :pin melpa-stable
    :config
    (setq cider-font-lock-dynamically '(macro core function var))
    (setq cider-eldoc-display-context-dependent-info t)
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-repl-use-pretty-printing t)
    (setq cider-repl-wrap-history t)
    (setq cider-repl-history-size 3000)
    (setq cider-repl-display-help-banner nil)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-mode-hook #'company-mode))

  (use-package clojure-mode-extra-font-locking
    :ensure t)

  (use-package clojure-mode
    :commands clojure-mode
    :ensure t
    :delight "clj"
    :config
    (put-clojure-indent 'Conditional 1)
    (put-clojure-indent 'ControlBar 0)
    (put-clojure-indent 'DisplayBlock 1)
    (put-clojure-indent 'Container 2)
    (put-clojure-indent 'IncludeIf 0)
    (put-clojure-indent 'Table 1)
    (put-clojure-indent 'protobuf 1)
    (put-clojure-indent 'POST 2)
    (put-clojure-indent 'GET 2)
    (add-hook 'clojure-mode-hook 'prettify-symbols-mode)
    (add-hook 'clojure-mode-hook 'paredit-mode)
    (add-hook 'clojure-mode-hook 'cider-mode)
    (setq clojure-indent-style nil))
#+end_src

** Emacs Lisp Mode

#+begin_src emacs-lisp
  (use-package emacs
    :ensure t
    :init
    (add-hook 'emacs-lisp-mode-hook (lambda ()
                                      (paredit-mode 1)
                                      (setq indent-tabs-mode nil)
                                      (local-set-key (kbd "RET") 'newline-and-indent)
                                      (company-mode 1)
                                      (hl-line-mode 1))))
#+end_src

** Go Mode

Revisit if I use Go again.

#+begin_src emacs-lisp
  (use-package flycheck-gometalinter
    :ensure t
    :config
    (flycheck-gometalinter-setup))

  (use-package go-eldoc
    :ensure t)

  (use-package go-mode
    :ensure t
    :commands go-mode
    :init
    (add-hook 'before-save-hook 'gofmt-before-save)
    (add-hook 'go-mode-hook 'flycheck-mode)
    :config
    (setq gofmt-command "goimports"))

  (use-package golint
    :ensure t)
#+end_src

** Groovy Mode

#+begin_src emacs-lisp
  (use-package groovy-mode
    :ensure t
    :defer t
    :mode (("\\.groovy" . groovy-mode)
           ("\\.gradle" . groovy-mode)))
#+end_src

** Java Mode

- [[https://github.com/emacs-lsp/lsp-ui]]

TODO: Check out this config [[https://github.com/hlissner/doom-emacs-private/blob/master/config.el][hlissner's config.el]] to see how I might customize lsp so it's not so facey.

#+begin_src emacs-lisp
  (use-package cc-mode
    :init
    (add-hook 'java-mode-hook (lambda ()
                                (hl-line-mode t)
                                (display-line-numbers-mode 1)
                                (setq c-basic-offset 4)
                                (setq tab-width 4)
                                (setq indent-tabs-mode nil))))

  (use-package lsp-mode
    :ensure t)

  (use-package hydra
    :ensure t)

  (use-package company-lsp
    :ensure t)

  (use-package lsp-ui
    :ensure t
    :config
    ;; If the popups get too tiresome, use this:
    (setq lsp-auto-configure nil))

  (use-package lsp-java
    :ensure t
    :after lsp
    :config (add-hook 'java-mode-hook (lambda ()
                                        (company-mode)
                                        (lsp)
                                        (flycheck-mode 1))))

  (use-package dap-mode
    :ensure t
    :after lsp-mode
    :config (progn (dap-mode t)
                   (dap-ui-mode t)))
#+end_src
** Javascript Mode

#+begin_src emacs-lisp
  (use-package js-mode
    :commands js-mode
    :init
    (add-hook 'js-mode-hook (lambda ()
                              (setq indent-tabs-mode nil)
                              (setq js-indent-level 2)
                              (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** Python Mode

#+begin_src emacs-lisp
  ;; (use-package elpy
  ;;   :ensure t
  ;;   :defer t
  ;;   :init
  ;;   (advice-add 'python-mode :before 'elpy-enable))

  ;; (use-package py-autopep8
  ;;   :ensure t
  ;;   :defer t
  ;;   :init
  ;;   (add-hook 'elpy-mode-hook 'py-autopep8-enable-on-save)
  ;;   (setq flycheck-python-pycompile- executable "python3"))

  (use-package lsp-python-ms
    :ensure t
    :hook (python-mode . (lambda ()
                           (require 'lsp-python-ms)
                           (lsp))))
#+end_src

** Swift Mode

#+begin_src emacs-lisp
  (use-package swift-mode
    :ensure t
    :defer t
    :config
    (add-hook 'swift-mode-hook (lambda ()
                                 ;; (setq swift-mode:basic-offset 4)
                                 ;; Doesn't also indent body.
                                 ;; (setq swift-mode:switch-case-offset 0)
                                 (setq indent-tabs-mode nil))))
#+end_src

* Settings
** Default directory

#+begin_src emacs-lisp
  (setq default-directory "~/")
#+end_src

** Hollow cursor

#+begin_src emacs-lisp
  (set-default 'cursor-type 'hollow)
#+end_src

** Global auto revert files (load if changed on disk)

Global Auto Revert mode is a global minor mode that reverts any buffer associated with a file when the file changes on disk.

#+begin_src emacs-lisp
  (global-auto-revert-mode 1)
#+end_src

** Truncate lines

Do not wrap lines when they're too long.

#+begin_src emacs-lisp
  (setq-default truncate-lines t)
#+end_src

** Electric parens

Toggle automatic parens pairing (Electric Pair mode).

#+begin_src emacs-lisp
  (electric-pair-mode 1)
#+end_src

** Replace selected text when you type something

When Delete Selection mode is enabled, typed text replaces the selection if the selection is active. Otherwise, typed text is just inserted at point regardless of any selection.

#+begin_src emacs-lisp
  (delete-selection-mode 1)
#+end_src

** Show column numbers in the mode line

Toggle column number display in the mode line (Column Number mode).

#+begin_src emacs-lisp
  (column-number-mode 1)
#+end_src

** Use regular keys for cut/copy/paste (cua-mode)

CUA mode is a global minor mode. When enabled, typed text replaces the active selection, and you can use C-z, C-x, C-c, and C-v to undo, cut, copy, and paste in addition to the normal Emacs bindings. The C-x and C-c keys only do cut and copy when the region is active, so in most cases, they do not conflict with the normal function of these prefix keys.

#+begin_src emacs-lisp
  (cua-mode 1)
#+end_src

** Show matching parens

Toggle visualization of matching parens (Show Paren mode).

#+begin_src emacs-lisp
  (show-paren-mode t)
#+end_src

** Font resizing keyboard bindings

Mimics normal Mac keybindings for font resizing.

#+begin_src emacs-lisp
  (global-set-key (kbd "s-+") 'text-scale-increase)
  (global-set-key (kbd "s-_") 'text-scale-decrease)
#+end_src

** Window navigation keyboard commands

#+begin_src emacs-lisp
  (global-set-key (kbd "M-`") 'other-frame)
  (global-set-key (kbd "s-<right>") 'windmove-right)
  (global-set-key (kbd "s-<left>") 'windmove-left)
  (global-set-key (kbd "s-<up>") 'windmove-up)
  (global-set-key (kbd "s-<down>") 'windmove-down)
#+end_src
** Window placement

Rules:

 - Terminal windows appear at the bottom.

#+begin_src emacs-lisp
  (use-package emacs
    :init
    (setq display-buffer-alist
          '((".*vterm.*"
             (display-buffer-in-side-window)
             (window-parameters . ((mode-line-format . (" " mode-line-buffer-identification))))
             (window-height . 0.2)
             (side . bottom)
             (slot . 0)))))
#+end_src

** Uncategorized

#+begin_src emacs-lisp

    ;; banish custom config to another file
    (setq custom-file "~/.emacs.d/custom.el")

    ;; UTF0-8 (still necessary?)
    (prefer-coding-system 'utf-8)
    (when (display-graphic-p)
      (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))

    ;; Don't require spelling out yes or no.
    (fset 'yes-or-no-p 'y-or-n-p)

    (setq make-backup-files nil)
    (setq auto-save-default nil)

    (if (display-graphic-p)
        (progn (scroll-bar-mode 0)
               (fringe-mode '(10 . 10)))
      (progn (menu-bar-mode 0)))

    (setq ns-use-mwheel-momentum nil)
    (pixel-scroll-mode 0)

    (custom-set-variables '(indent-tabs-mode nil))
    (setq-default line-spacing 1)
    (setq-default inhibit-startup-screen t)
    (setq-default standard-indent 2)
    (setq-default tab-width 2)
    (add-hook 'before-save-hook 'whitespace-cleanup)
    (blink-cursor-mode 0)
    (setq ring-bell-function 'ignore)

    ;; Set the frame title to the visited file's path
    ;; using the abbreviated form (~ for home).
    (setq frame-title-format
          '((:eval (if (buffer-file-name)
                       (abbreviate-file-name (buffer-file-name))
                     "%b"))))

    ;;-----------------------------------------------------------------------------
    ;; Line numbers mode
    ;;-----------------------------------------------------------------------------

    (defvar display-line-numbers-grow-only)
    (defvar display-line-numbers-width-start)

    (when (version<= "26.0.50" emacs-version)
      ;; (global-display-line-numbers-mode 1)
      (setq display-line-numbers-grow-only t)
      (setq display-line-numbers-width-start 1000))

    ;;-----------------------------------------------------------------------------

    ;; (defun kfi/fix-echo-area ()
    ;;   "Set the font for the message window."
    ;;   (let ((buf (get-buffer " *Echo Area 0*")))
    ;;     (when buf
    ;;       (with-current-buffer buf
    ;;         (setq-local face-remapping-alist '((default :family "Menlo" :weight normal :height 100)))))))

    ;; (defun kfi/craft-minibuffer ()
    ;;   "Set the font for the minibuffer."
    ;;   (set (make-local-variable 'face-remapping-alist)
    ;;        '((default :family "Menlo" :weight normal :height 100))))

    ;; (when (display-graphic-p)
    ;;   (add-hook 'minibuffer-setup-hook 'kfi/craft-minibuffer)
    ;;   (kfi/fix-echo-area)
    ;;   (kfi/craft-minibuffer))

    (setq mac-command-modifier 'super)

    ;; GUI


    ;; Switch to next frame, if there is one.

    ;; Quick access to shell
    (global-set-key (kbd "C-c e") 'eshell)

    (setq ns-use-srgb-colorspace t)
#+end_src

* Custom Functions
** Theme Switchers

#+begin_src emacs-lisp
  (defun kfi/light ()
    (interactive)
    (disable-theme (car custom-enabled-themes))
    (load-theme 'doom-acario-light t))

  (defun kfi/dark ()
    "Apply the dark doom-one theme."
    (interactive)
    (disable-theme (car custom-enabled-themes))
    (load-theme 'doom-one t))
#+end_src

** Insert timestamp

What I use when I can't use [[https://www.keyboardmaestro.com/main/][Keyboard Maestro]]. Each of the formats could be made into a =yasnippet= (which is what I do with KB Maestro) using an elisp expression as its body. But I like the ~completing-read~ minibuffer menu thing here.

#+begin_src emacs-lisp
  (defvar kfi/timestamp-formats
    '(("March 15, 2020 @ 9:33 PM" . "%B %-d, %Y @ %-I:%M %p")
      ("2020-03-15T21:33:54"      . "%Y-%m-%dT%H:%M:%S")
      ("2020-03-15"               . "%Y-%m-%d")
      ("2020-03-15 09:35 PM"      . "%Y-%m-%d %I:%M %p")
      ("2020-03-15T21:39:20-0700" . "%FT%T%z"))
    "Formats for inserting a timestamp into a document.")

  (defun kfi/timestamp ()
    "Choose a format, then insert a timestamp."
    (interactive)
    (if-let* ((table kfi/timestamp-formats)
              (choices (mapcar #'car table))
              (choice (completing-read "Format:" choices))
              (format (cdr (assoc choice table))))
        (insert (format-time-string format))
      (insert "<error:nil-selection>")))
#+end_src

** Remove smart quotes from a buffer
#+begin_src emacs-lisp
  (defun kfi/unsmart ()
    "Remove smart quotes from buffer."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "’" nil t)
        (replace-match "'"))
      (goto-char (point-min))
      (while (re-search-forward "”" nil t)
        (replace-match "\""))
      (goto-char (point-min))
      (while (re-search-forward "“" nil t)
        (replace-match "\""))))
#+end_src

** Remove newlines until end of paragraph @bug

Actually, this doesn't do what I think it does: it seems to go to the stop of the buffer, when it should instead find the beginning of the paragraph. I wonder what the original intent was?

#+begin_src emacs-lisp
  (defun kfi/unwrap-line ()
    "Remove newlines until end-of-paragraph."
    (interactive)
    (let ((start (point-min))
          (end (copy-marker (or (search-forward "\n\n" nil t)
                                (point-max))))
          (fill-column (point-max)))
      (fill-region start end)
      (goto-char end)
      (newline)
      (goto-char start)))
#+end_src

** Set frame sizing functions

#+begin_src emacs-lisp
  (defun kfi/set-frame-width (arg)
    "Set the width of the frame to ARG."
    (interactive "nFrame width: ")
    (set-frame-width (selected-frame) arg))

  (defun kfi/dw ()
    "Set frame to double-wide."
    (interactive)
    (kfi/set-frame-width 180))

  (defun kfi/sw ()
    "Set frame to single-wide."
    (interactive)
    (kfi/set-frame-width 90))

  (global-set-key (kbd "C-c C-x w") 'kfi/dw)
  (global-set-key (kbd "C-c C-x s") 'kfi/sw)

  (defun kfi/set-frame-height (arg)
    "Set frame height to ARG."
    (interactive "nFrame height: ")
    (set-frame-height (selected-frame) arg))

  (defun kfi/set-frame-dimensions (w h)
    "Set frame dimensions to W and H."
    (interactive "nFrame width: \nnFrame height: ")
    (set-frame-width (selected-frame) w)
    (set-frame-height (selected-frame) h))
#+end_src

** Go back to the previous window

#+begin_src emacs-lisp
  (defun kfi/back-window ()
    "Go back to previously visited window."
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x p") 'kfi/back-window)
#+end_src

** Open the current file in whatever MacOS thinks is the appropriate handler
#+begin_src emacs-lisp
  (defun kfi/open-this ()
    "Open the buffer using MacOS defaults."
    (interactive)
    (shell-command (concat "open '" (buffer-file-name) "'")))

  (global-set-key (kbd "C-c C-x o") 'kfi/open-this)

#+end_src

** Adjust font size up or down

#+begin_src emacs-lisp
  (defun kfi/set-font-size (size)
    "Set the font SIZE."
    (interactive "nNew size: ")
    (set-face-attribute 'default nil :height size))

  (defun kfi/font-size-up ()
    "Shift font size up by 10 units."
    (interactive)
    (kfi/set-font-size (+ (face-attribute 'default :height) 10)))

  (defun kfi/font-size-down ()
    "Shift font size down by 10 units."
    (interactive)
    (kfi/set-font-size (- (face-attribute 'default :height) 10)))
#+end_src

** Generate some lorem ipsum text

#+begin_src emacs-lisp
  (defun kfi/lorem ()
    "Output a bunch of lorem ipsum text."
    (interactive)
    (insert
     "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
     "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
     "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
     "aliquip ex ea commodo consequat. Duis aute irure dolor in "
     "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
     "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
     "culpa qui officia deserunt mollit anim id est laborum."))
#+end_src

** Sort the words in the current selection

#+begin_src emacs-lisp
  (defun kfi/sort-words (reverse beg end)
    "Sort region words REVERSE if negative from BEG to END.
  Prefixed with negative \\[universal-argument], sorts in reverse.
  The variable `sort-fold-case' determines whether alphabetic case
  affects the sort order.  See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))
#+end_src

** Make the background (and foreground) slight transparent (or not)

#+begin_src emacs-lisp
  (defun kfi/transparency-on ()
    "Turn on frame transparency."
    (interactive)
    (set-frame-parameter nil 'alpha '(95 95))
    (add-to-list 'default-frame-alist '(alpha 95 95)))

  (defun kfi/transparency-no ()
    "Turn off frame transparency."
    (interactive)
    (set-frame-parameter nil 'alpha '(100 100))
    (add-to-list 'default-frame-alist '(alpha 100 100)))
#+end_src

** Set/Unset prose writing mode

#+begin_src emacs-lisp
  (defun kfi/write-mode ()
    "Set special prose writing mode."
    (interactive)
    (display-line-numbers-mode -1)
    (global-hl-line-mode 0)
    (olivetti-mode 1)
    (flyspell-mode 1)
    (flyspell-buffer))

  (defun kfi/unwrite-mode ()
    "Unset special prose writing mode."
    (interactive)
    (global-hl-line-mode 1)
    (olivetti-mode 0)
    (flyspell-mode 0)
    (display-line-numbers-mode 1))
#+end_src

** Visit Emacs' init.el file

#+begin_src emacs-lisp
  (defun kfi/edit-init-el ()
    "Visit the init.el file."
    (interactive)
    (find-file "~/.emacs.d/init.el"))
#+end_src

** Visit configuration.org for Emacs

#+begin_src emacs-lisp
  (defun kfi/my-config ()
    "Visit my configuration.org file for Emacs."
    (interactive)
    (find-file "~/.emacs.d/configuration.org"))
#+end_src
* Futures

** Find a way for fly-spell to not check certain words

Do something like the following, and have that function check for words beginning and ending with "=" or "@" or "#" or "~".

#+begin_src block
  (add-hook 'java-mode-hook
            (lambda ()
              (setq flyspell-generic-check-word-predicate 'my-new-function)))
#+end_src

Also check: https://emacs.stackexchange.com/a/31302 for using faces to avoid spellchecking in comments, though I'm not sure this will work in org-mode given it's not a programming mode. Hm.

#+begin_src block
  (setq flyspell-prog-text-faces
        (delq 'font-lock-string-face
              flyspell-prog-text-faces))
#+end_src
