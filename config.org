#+title: Emacs Configuration
#+author: Keith Irwin
#+startup: content

Using org-mode for this because it's a bit easier to navigate around
for endless tweaking. Any additional narrative is catch as catch can.

* buffer backups

#+begin_src emacs-lisp :tangle yes
  (setq backup-directory-alist `(("." . "~/.emacs.d/backups/")))
  (setq backup-inhibited t)
  (setq auto-save-default nil)
#+end_src

* executable environment

#+begin_src emacs-lisp :tangle yes
  (setq default-directory "~/")

  (defvar kfi-local-bin (concat (getenv "HOME") "/bin") "Local execs.")
  (defvar usr-local-bin "/usr/local/bin")
  (defvar tex-bin "/Library/TeX/texbin")
  (defvar go-path (concat (getenv "HOME") "/workspace/go/bin") "Go workspace.")

  (setenv "PATH" (concat usr-local-bin ":" (getenv "PATH") ":" kfi-local-bin ":" go-path ":" tex-bin))
  (setenv "LEIN_JVM_OPTS" "-Djava.awt.headless=true")

  (setq exec-path (append exec-path (list kfi-local-bin usr-local-bin go-path tex-bin)))
#+end_src

* erc (irc client)

I like to close Emacs more often than IRC, but I still use this
sometimes. Note that theme adjustments are elsewhere, not included
here.

#+begin_src emacs-lisp :tangle yes
  (use-package erc-hl-nicks
    :ensure t)

  (use-package erc
    :ensure t
    :config
    (defun kfi-erc-mode-hook ()
      (make-local-variable 'global-hl-line-mode)
      (setq global-hl-line-mode nil))

    (add-hook 'erc-mode-hook 'kfi-erc-mode-hook)

    ;; Not sure if this is necessary.
    (progn (add-to-list 'erc-modules 'truncate)
           (add-to-list 'erc-modules 'scrolltobottom)
           (erc-update-modules))

    (erc-scrolltobottom-mode 1)

    (setq erc-hide-list '("JOIN" "PART" "QUIT"))
    (setq erc-fill-prefix "    ")
    (setq erc-prompt (lambda () (concat "\n" (buffer-name) " >")))

    (setq erc-fill-column 79)
    (setq erc-scroll-to-bottom -2)
    (setq erc-truncate-buffer-on-save t)
    (setq erc-max-buffer-size 30000)

    (defvar erc-insert-post-hook)
    (add-hook 'erc-insert-post-hook
              'erc-truncate-buffer)
    (setq erc-truncate-buffer-on-save t))
#+end_src



* Extensions

Packages for customizing Emacs itself.

** command-log-mode

Cool thing that displays all your commands as you type them. It's for
demos, but I just like it for fun.

#+begin_src emacs-lisp :tangle yes
  (use-package command-log-mode
    :ensure t)
#+end_src

** dirtree

#+begin_src emacs-lisp :tangle yes
  (use-package dirtree
    :ensure t)
#+end_src

** fullframe

[[https://github.com/tomterl/fullframe][home page]]

#+begin_src emacs-lisp :tangle yes
  (use-package fullframe
    :ensure t)
#+end_src

** dired-details

Shortens up the dired buffer, removing dates, file-sizes and so
on. Most of the time I just want a list of files.

#+begin_src emacs-lisp :tangle yes
  (use-package dired-details
    :ensure t
    :config
    (setq-default dired-details-hidden-string "--- ")
    (dired-details-install))
#+end_src

** ivy-mode, swiper, counsel

/Disabled for now./

This is yet another version of ~ido~ or ~helm~ which claims to be
simpler and cleaner than all the others. I. Want. To. Believe.

Here's a link for integrating OSX's ~mdfind~ or Spotlight Search into
~counsel~.

 - [[http://pragmaticemacs.com/emacs/super-spotlight-search-with-counsel/][Super spotlight search with counsel]]
 - http://oremacs.com/swiper/
 - https://github.com/abo-abo/swiper/wiki/Don%27t-open-directory-mode

#+begin_src emacs-lisp :tangle yes
  (use-package ag
    :ensure t)

  (use-package counsel
    :disabled t
    :ensure t
    :config
    ;; Hide .dot files, other 'hidden' detritus
    (setq counsel-find-file-ignore-regexp "\\(?:\\`[#.]\\)\\|\\(?:[#~]\\'\\)"))

  (use-package swiper
    :disabled t
    :ensure t
    :config
    (ivy-mode 1)
    (setq ivy-use-virtual-buffers t)
    (setq ivy-height 30)
    (global-set-key "\C-s" 'swiper)
    (global-set-key (kbd "C-c C-r") 'ivy-resume)
    (global-set-key (kbd "<f6>") 'ivy-resume)
    (global-set-key (kbd "M-x") 'counsel-M-x)
    (global-set-key (kbd "C-x C-f") 'counsel-find-file)
    (global-set-key (kbd "<f1> f") 'counsel-describe-function)
    (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
    (global-set-key (kbd "<f1> l") 'counsel-load-library)
    (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
    (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
    ;;(global-set-key (kbd "C-x l") 'counsel-locate)
    ;;(global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
    ;;(global-set-key (kbd "C-c g") 'counsel-git)
    ;;(global-set-key (kbd "C-c j") 'counsel-git-grep)
    (global-set-key (kbd "C-c a") 'projectile-ag)
    (global-set-key (kbd "C-c k") 'counsel-ag)
    ;;(setq ivy-re-builders-alist '((t . ivy--regex-fuzzy)))
    ;;(setq ivy-re-builders-alist '((t . ivy--regex-plus)))

    (setq ivy-extra-directories nil)

    (defun eh-ivy-open-current-typed-path ()
      (interactive)
      (when ivy--directory
        (let* ((dir ivy--directory)
               (text-typed ivy-text)
               (path (concat dir text-typed)))
          (delete-minibuffer-contents)
          (ivy--done path))))

    (define-key ivy-minibuffer-map (kbd "<return>") 'ivy-alt-done)
    (define-key ivy-minibuffer-map (kbd "C-f") 'eh-ivy-open-current-typed-path)
    )
#+end_src

** helm

Trying out [[https://github.com/emacs-helm/helm][Helm]] which is a world unto itself. A much more
sophisticated "ido" kind of thing.

/Disabled for now./

#+begin_src emacs-lisp :tangle yes
  ;; (use-package helm
  ;;   ;; http://tuhdo.github.io/helm-intro.html#sec-31
  ;;   :disabled t
  ;;   :ensure t
  ;;   :diminish helm-mode
  ;;   :config (progn

  ;;             (require 'helm-config)

  ;;             (helm-mode)
  ;;             (helm-autoresize-mode t)
  ;;             (setq helm-locate-command "mdfind -interpret -name %s %s"
  ;;                   helm-full-frame t
  ;;                   helm-ff-newfile-prompt-p nil
  ;;                   helm-M-x-fuzzy-match t
  ;;                   helm-autoresize-max-height 40
  ;;                   helm-autoresize-min-height 40
  ;;                   helm-ff-skip-boring-files t)
  ;;             ;; (let ((tmp helm-boring-file-regexp-list))
  ;;             ;;   (setq helm-boring-file-regexp-list (append tmp '("\\.[A-Za-z]+"))))
  ;;             ;; rebind tab to do persistent action
  ;;             (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action)
  ;;             ;; make TAB works in terminal
  ;;             (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action)
  ;;             ;; list actions using C-z
  ;;             (define-key helm-map (kbd "C-z")  'helm-select-action)
  ;;             (bind-key (kbd "M-x") 'helm-M-x))

  ;;   :bind (("C-c h" . helm-command-prefix)
  ;;          ("C-x b" . helm-mini)
  ;;          ("C-`" . helm-resume)
  ;;          ("M-x" . helm-M-x)
  ;;          ("C-x C-f" . helm-find-files)))

  ;; (use-package helm-projectile
  ;;   :disabled t
  ;;   :ensure t
  ;;   :commands helm-projectile
  ;;   :bind ("s-p" . helm-projectile))

  ;; (use-package helm-ag
  ;;   :disabled t
  ;;   :ensure t
  ;;   :config
  ;;   (setq helm-ag-base-command "/usr/local/bin/ag --nocolor --nogroup --ignore-case")
  ;;   (setq helm-ag-command-option "--all-text")
  ;;   (setq helm-ag-insert-at-point 'symbol))

  ;; (global-set-key (kbd "C-c a") 'helm-do-grep-ag)
#+end_src

** ido/smex

Ido and smex comprise a more Emacs-y command and file completion mode
which I might return to if helm makes my eyes bleed too much.

#+begin_src emacs-lisp :tangle yes
  (use-package ido
    :ensure t
    :init
    (progn (ido-mode 1)

           (setq ido-enable-flex-matching t)
           (setq ido-everywhere t)

           (use-package ido-ubiquitous
             :ensure t
             :init (ido-ubiquitous-mode))
           (use-package flx-ido
             :ensure t
             :init
             (flx-ido-mode 1)
             (setq ido-enable-flex-matching t)
             (setq ido-use-faces nil))
           (use-package ido-vertical-mode
             :ensure t
             :init
             (ido-vertical-mode 1)
             (setq ido-vertical-define-keys 'C-n-C-p-up-and-down))))

  (use-package smex
    :ensure t
    :bind ("M-x" . smex))
#+end_src

** kfi-functions

Some functions I find useful, when I remember them.

#+begin_src emacs-lisp :tangle yes
  ;; https://www.emacswiki.org/emacs/UnwrapLine
  (defun kfi-unwrap-line ()
    "Remove all newlines until we get to two consecutive ones.
      Or until we reach the end of the buffer.
      Great for unwrapping quotes before sending them on IRC."
    (interactive)
    (let ((start (point))
          (end (copy-marker (or (search-forward "\n\n" nil t)
                                (point-max))))
          (fill-column (point-max)))
      (fill-region start end)
      (goto-char end)
      (newline)
      (goto-char start)))

  (defun kfi-set-frame-width (arg)
    (interactive "nFrame width: ")
    (set-frame-width (selected-frame) arg))

  (defun kfi-dw ()
    "Double-wide with C-c C-x w."
    (interactive)
    (kfi-set-frame-width 180))

  (defun kfi-sw ()
    "Single wide with C-c C-x s."
    (interactive)
    (kfi-set-frame-width 90))

  (defun kfi-set-frame-height (arg)
    (interactive "nFrame height: ")
    (set-frame-height (selected-frame) arg))

  (defun kfi-set-frame-dimensions (w h)
    (interactive "nFrame width: \nnFrame height: ")
    (set-frame-width (selected-frame) w)
    (set-frame-height (selected-frame) h))

  (defun kfi-back-window ()
    (interactive)
    (other-window -1))

  (global-set-key (kbd "C-x p") 'kfi-back-window)

  (defun kfi-open-this ()
    (interactive)
    (shell-command (concat "open '" (buffer-name) "'")))

  (global-set-key (kbd "C-c C-x o") 'kfi-open-this)
  (global-set-key (kbd "C-c C-x w") 'kfi-dw)
  (global-set-key (kbd "C-c C-x s") 'kfi-sw)

  (defun kfi-set-font-size (size)
    (interactive "nNew size: ")
    (set-face-attribute 'default nil :height size))

  (defun kfi-font-size-up ()
    (interactive)
    (kfi-set-font-size (+ (face-attribute 'default :height) 10)))

  (defun kfi-font-size-down ()
    (interactive)
    (kfi-set-font-size (- (face-attribute 'default :height) 10)))

  (defun kfi-lorem ()
    (interactive)
    (insert "Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do "
            "eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim"
            "ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut "
            "aliquip ex ea commodo consequat. Duis aute irure dolor in "
            "reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla "
            "pariatur. Excepteur sint occaecat cupidatat non proident, sunt in "
            "culpa qui officia deserunt mollit anim id est laborum."))

  (defun kfi-sort-words (reverse beg end)
    "Sort words in region alphabetically, in REVERSE if negative.
           Prefixed with negative \\[universal-argument], sorts in reverse.

           The variable `sort-fold-case' determines whether alphabetic case
           affects the sort order.

           See `sort-regexp-fields'."
    (interactive "*P\nr")
    (sort-regexp-fields reverse "\\w+" "\\&" beg end))

  ;; open up the work log file

  (defun kfi-worklog ()
    (interactive)
    (find-file "~/Documents/Textbox/worklog.org"))

  (defun kfi-econfig ()
    (interactive)
    (find-file "~/.emacs.d/config.org"))

  (global-set-key (kbd "C-c w") 'kfi-worklog)
  (global-set-key (kbd "C-c k") 'kfi-econfig)
#+end_src

* Program Facilities

A bunch of stuff broadly applicable to any programming language
environment.

** yasnippets

Starting to use snippets just a little, mainly in markup languages.

#+begin_src emacs-lisp :tangle yes
  (use-package yasnippet
    :ensure t
    :config
    (setq yas-snippet-dirs (list (concat user-emacs-directory "snippets/")
                                 yas-installed-snippets-dir))
    (yas-global-mode 1))
#+end_src

** projectile

[[https://github.com/bbatsov/projectile][Projectile]] has become increasingly useful especially for front-end web
application development which tends towards lots of files.

#+begin_src emacs-lisp :tangle yes
  (use-package projectile
    :ensure t
    :commands projectile-global-mode
    :config
    (setq projectile-completion-system 'ido)
    ;;(setq projectile-completion-system 'helm)
    )
#+end_src

** dash

Trying this out. I use [[https://kapeli.com/dash][Dash]] a lot, especially when I don't know the
name of something. This package lets you point at something and look
it up, which is more handy for reading other peoples' code.

#+begin_src emacs-lisp :tangle yes
  (use-package dash-at-point
    :ensure t
    :bind (("s-D"     . dash-at-point)
           ("C-c e"   . dash-at-point-with-docset)))
#+end_src

** magit

[[http://magit.vc][Magit]] is a super nice Git client. Feels like the command line, but has
nice visual components. In a lot of ways, Emacs seems like an
alternate reality where the Mac-like GUI universe never happened and
thus killed non-GUI innovation.

#+begin_src emacs-lisp :tangle yes
  (use-package magit
    :ensure t
    :config

    (defun kfi-toggle-magit-revert-buffers ()
      (interactive)
      (setq magit-revert-buffers
            (if (eq nil magit-revert-buffers)
                (progn
                  (message "Setting revert-buffers to 'usage.")
                  'usage)
              (progn
                (message "Setting revert-buffers to nil.")
                nil))))

    ;; Courtesy Magnars
    (defadvice magit-status (around magit-fullscreen activate)
      (window-configuration-to-register :magit-fullscreen)
      ad-do-it
      (delete-other-windows))

    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (jump-to-register :magit-fullscreen))

    (define-key magit-status-mode-map (kbd "q") 'magit-quit-session)

    (global-set-key (kbd "C-c g") 'magit-status)
    (global-set-key (kbd "C-c l") 'magit-log))
#+end_src

** paredit

Paredit is a transformative thought technology in the same way Lisp
is.

#+begin_src emacs-lisp :tangle yes
  (use-package paredit
    :ensure t)
#+end_src

** company

Cider depends on company mode for completion. I'm not a big fan of
completion most of the time. I always turn it off in IDEs, which is
why I end up turning any IDE I use into an editor.

#+begin_src emacs-lisp :tangle yes
  (use-package company
    :ensure t)
#+end_src

** linum-mode

Occasionally useful. I leave this at the default: off. There are some
theme customizations above.

#+begin_src emacs-lisp :tangle yes
  (use-package linum
    :ensure t
    :config
    (setq linum-format "%4d "))
#+end_src

* Web Programming
** web-mode

#+begin_src emacs-lisp :tangle yes
  (use-package web-mode
    :ensure t
    :mode ("\\.html?\\'" "\\.js?\\'" "\\.jsx$")
    :config
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-indent-style 2)
    (setq web-mode-content-types
          (cons '("jsx" . "\\.js\\'") web-mode-content-types))
    (set-face-attribute 'web-mode-html-tag-face nil :foreground "cornflowerblue")
    (set-face-attribute 'web-mode-html-tag-bracket-face nil :foreground "goldenrod"))
#+end_src

** css-mode

#+begin_src emacs-lisp :tangle yes
  (use-package css-mode
    :ensure t
    :config
    (setq css-indent-offset 2)
    (add-hook 'css-mode-hook '(lambda ()
                                (local-set-key (kbd "RET") 'newline-and-indent))))
#+end_src

** restclient

[[https://github.com/pashky/restclient.el][home page]]

Handy mode for running raw web requests. Alas, not particularly good
for web-sockets.

#+begin_src emacs-lisp :tangle yes
  (use-package restclient
    :ensure t
    :config
    (setq restclient-same-buffer-response t))
#+end_src

** JSON mode

#+begin_src emacs-lisp :tangle yes
(use-package json-mode
  :ensure t)
#+end_src


* clojure

*paren-face**

Dimming the parenthesis really emphasizes the semantics of the
expressions over their syntax. Right?

#+begin_src emacs-lisp :tangle yes
  (use-package paren-face
    :ensure t
    :config
    (global-paren-face-mode 1))
#+end_src

*clojure-mode*

#+begin_src emacs-lisp :tangle yes
  (use-package clojure-mode-extra-font-locking
    :ensure t)

  (use-package clojure-mode
    :ensure t
    :config
    (setq clojure-defun-style-default-indent nil)

    ;; (defconst kfi-clj-anonfn
    ;;   `(("\\(#\\)("
    ;;      (0 (progn (compose-region (match-beginning 1)
    ;;                                (match-end 1) "9")
    ;;                nil)))))

    ;; (font-lock-add-keywords 'clojure-mode       kfi-clj-anonfn)
    ;; (font-lock-add-keywords 'clojurescript-mode kfi-clj-anonfn)
    (add-hook 'clojure-mode-hook 'prettify-symbols-mode)
    (add-hook 'clojure-mode-hook 'paredit-mode)
    (add-hook 'clojure-mode-hook 'cider-mode))
#+end_src

*cider*

Cider! The Clojure IDE. A ton of features, most of which I can ignore.

References:

 - [[http://endlessparentheses.com/using-prettify-symbols-in-clojure-and-elisp-without-breaking-indentation.html?source=rss][pretty symbols]]

#+begin_src emacs-lisp :tangle yes
  (use-package cider
    :ensure t
    :config
    (setq cider-font-lock-dynamically '(macro core function var))
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-overlays-use-font-lock t)
    (add-hook 'cider-repl-mode-hook 'paredit-mode)
    (add-hook 'cider-repl-mode-hook 'company-mode)
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (add-hook 'cider-mode-hook 'company-mode)
    (add-hook 'cider-mode-hook #'eldoc-mode)
    (setq cider-repl-use-pretty-printing 1)
    (setq cider-cljs-lein-repl
          (concat "(do (require 'user) "
                  "    (user/start-cljs)"
                  "    (user/repl-cljs))")))
#+end_src

* javascript

Can't avoid it, though I mostly do by using ClojureScript.

#+begin_src emacs-lisp :tangle yes
  (use-package js
    :ensure t
    :config
    (defun kfi-js-mode-hook ()
      (setq indent-tabs-mode nil)
      (setq js-indent-level 2)
      (local-set-key (kbd "RET") 'newline-and-indent))

    (add-hook 'js-mode-hook #'kfi-js-mode-hook))
#+end_src

* golang

Maybe this is worth getting into for simple, small-memory-footprint
servers and the like?

- http://dominik.honnef.co/posts/2013/03/writing_go_in_emacs/
- https://github.com/dominikh/go-mode.el

#+begin_src emacs-lisp :tangle yes
  (use-package go-mode
    :ensure t
    :config
    (add-hook 'before-save-hook 'gofmt-before-save)
    (setq gofmt-command "goimports")
    (defun kfi-go-mode-hook ()
      (local-set-key (kbd "C-c C-r" 'go-remove-unused-imports))
      (local-set-key (kbd "C-c i" 'go-goto-imports)))
    (add-hook 'go-mode-hook #'kfi-go-mode-hook))
#+end_src


* htmlize

This helps org-mode export colorize code blocks. I think. Do I still
need this?

#+begin_src emacs-lisp :tangle yes
  (use-package htmlize
    :ensure t)
#+end_src

* org-mode

#+begin_src emacs-lisp :tangle yes
  (use-package org-plus-contrib
    :ensure t
    :pin org
    :init (add-hook 'org-mode-hook 'turn-on-auto-fill)
    :config (progn
              (setq
               org-html-doctype "html5"
               org-export-with-smart-quotes t
               org-replace-disputed-keys t
               org-src-fontify-natively t)
              (setq org-html-head "<style>
                  html { font-family: helvetica, sans-serif; padding: 50px; }
                  table { width: 100%; border-collapse: collapse; font-size: 10pt }
                  p { line-height: 1.5em; }
                  li { line-height: 1.5em; }
                  tr:nth-child(odd) {background: aliceblue}
                  tr:nth-child(even) {background: #fff}
                  th { padding: 4px; font-weight: 400; border: 1px solid #d6d6d6;
                       background-color: #f6f6f6; text-align: left !important; }
                  td { padding: 4px; border: 1px solid #d8d8d8; }
                </style>")))

  (use-package org-bullets
    :ensure t
    :init
    (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+end_src

* markdown

#+begin_src emacs-lisp :tangle yes
  (use-package markdown-mode
    :ensure t
    :mode ("\\.markdown$" "\\.md$"
           "\\.mkd$"
           "\\.mkdn$"
           "\\.mdown$"
           "\\.mdwn$" "\\.text$")
    :config
    (defun kfi-markdown-mode-hook ()
      (auto-fill-mode 1))

    (add-hook 'markdown-mode-hook 'kfi-markdown-mode-hook))
#+end_src

* html

The idea is to not have to press tab at the beginning of every
line. No that I type HTML much anymore.

#+begin_src emacs-lisp :tangle yes
  (add-hook 'html-mode-hook '(lambda ()
    (local-set-key (kbd "RET") 'newline-and-indent)))
#+end_src



* Unsorted

Random stuff I've not sorted into the outline because I just need to
get it ported to this file. Move later! Move later?

** melpa-upstream-visit

Last update was 2013. Do I need this anymore?

#+begin_src emacs-lisp :tangle yes
  (use-package melpa-upstream-visit
    :ensure t)
#+end_src

** multi-term

#+begin_src emacs-lisp :tangle yes
  (use-package multi-term
    :ensure t)
#+end_src

** multiple-cursors

I need to figure out that mode where you can highlight a fragment,
then optionally select the additional fragments. I use this /a lot/
for search and replace kinds of operations and sometimes the thing I'm
searching for is common enough to be embedded in lots of other
symbols.

#+begin_src emacs-lisp :tangle yes
  (use-package multiple-cursors
    :ensure t
    :config
    (global-set-key (kbd "C-M->") 'mc/mark-all-like-this)
    (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
    (global-set-key (kbd "C->") 'mc/mark-next-like-this))
#+end_src

** emacs-lisp

#+begin_src emacs-lisp :tangle yes
  (defun kfi-elisp-hook ()
    (paredit-mode 1)
    (setq indent-tabs-mode nil)
    (local-set-key (kbd "RET") 'newline-and-indent))

  (add-hook 'emacs-lisp-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'lisp-interaction-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'ielm-mode-hook 'turn-on-eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook #'kfi-elisp-hook)
#+end_src

** ibuffer - grouped buffer menu

#+begin_src emacs-lisp :tangle yes
  (global-set-key (kbd "C-x C-b") 'ibuffer)
  (global-set-key (kbd "<C-tab>") 'ibuffer)

  (setq ibuffer-saved-filter-groups
        (quote (("default"
                 ("org" (mode . org-mode))
                 ("clojure" (mode . clojure-mode))
                 ("clojure-script" (mode . clojurescript-mode))
                 ("go-lang" (mode . go-mode))
                 ("web" (or (mode . css-mode)
                            (mode . html-mode)
                            (mode . js-mode)))
                 ("erc" (name . "^\\#"))
                 ("elisp" (mode . emacs-lisp-mode))
                 ("dirs" (mode . dired-mode))
                 ("temps" (name . "^\\*.*\\*$"))
                 ;;
                 ))))

  (add-hook 'ibuffer-mode-hook
            (lambda ()
              (ibuffer-switch-to-saved-filter-groups "default")))
#+end_src

** java

I almost never futz with Java in Emacs, at least not any "real"
project. But here we are anyway, just in case.

#+begin_src emacs-lisp :tangle yes
  (defun kfi-java-hook ()
    (setq c-basic-offset 2
          tab-width 2
          indent-tabs-mode nil))

  (add-hook 'java-mode-hook #'kfi-java-hook)
#+end_src

** keyboard

#+begin_src emacs-lisp :tangle yes
  (setq mac-command-modifqier 'super)

  ;; Have I duped this somewhere else?
  (global-set-key (kbd "s-p") 'projectile-find-file)

  ;; On OSX C-M-@ amd M-S-SPC doesn't work when running in a
  ;; terminal.
  (global-set-key (kbd "C-M-SPC") 'mark-sexp)
  (global-set-key (kbd "M-RET") 'mark-sexp)

  ;; GUI
  (global-set-key (kbd "s-<right>") 'windmove-right)
  (global-set-key (kbd "s-<left>") 'windmove-left)
  (global-set-key (kbd "s-<up>") 'windmove-up)
  (global-set-key (kbd "s-<down>") 'windmove-down)

  ;; Mimics normal Mac keybindings for font resizing
  (global-set-key (kbd "s-+") 'text-scale-increase)
  (global-set-key (kbd "s-_") 'text-scale-decrease)

  ;; Switch to next frame, if there is one.
  (global-set-key (kbd "M-`") 'other-frame)

  ;; Quick access to sshell
  (global-set-key (kbd "C-c h") 'eshell)

  (global-set-key (kbd "C-c m 1")
                  (lambda ()
                    (interactive)
                    (set-face-attribute 'default nil :family "Monaco" :height 120 :weight 'normal)))

  (global-set-key (kbd "C-c m 2")
                  (lambda ()
                    (interactive)
                    (set-face-attribute 'default nil :family "Input Mono Narrow" :height 120 :weight 'normal)))

  (global-set-key (kbd "C-c m 3")
                  (lambda ()
                    (interactive)
                    (set-face-attribute 'default nil :family "Input Mono Narrow" :height 120 :weight 'thin)))

  (global-set-key (kbd "C-c s")
                  (lambda ()
                    (interactive)
                    (switch-to-buffer (get-buffer-create "*scratch*"))
                    (emacs-lisp-mode)
                    (when (eq (length (buffer-string)) 0)
                      (insert ";; scratch\n\n"))))
#+end_src

** emacs-server

#+begin_src emacs-lisp :tangle yes
  (when (not (server-running-p))
      (server-start))
#+end_src

** shell-script

#+begin_src emacs-lisp :tangle yes
  (setq sh-basic-offset 2)
  (setq sh-indentation 2)
#+end_src

** terminal

Every now and then I run shells from within Emacs. I think I need to
change my technique on this. Use eshell for running quick tasks
related to the code, but use a regular terminal outside of Emacs for
most other stuff.

Nevertheless, here's what I've been using for quite some time. The
main limitation is not detecting the underlying theme such that the
shell background is appropriate.

#+begin_src emacs-lisp :tangle yes
  (require 'multi-term)

  ;; Turn off stuff that only makes sense in a regular buffer.
  (defadvice term-char-mode (after term-char-mode-fixes ())
    ;; Causes a compile-log warning. Do I even need this any more?
    ;; (set (make-local-variable 'hl-line-mode) nil)
    (set (make-local-variable 'global-hl-line-mode) nil))

  (ad-activate 'term-char-mode)

  (setq multi-term-program "/bin/bash")
  (set-face-attribute 'term nil :background "black")
  (set-face-attribute 'term nil :foreground "#aaaaaa")
  (set-face-attribute 'term-color-cyan nil :foreground "dodgerblue")
  (set-face-attribute 'term-color-black nil :foreground "gray50")
  (set-face-attribute 'term-color-yellow nil :foreground "peru")

  ;; (when (string= (face-attribute 'default :background) "White")
  ;;   (set-face-attribute 'term nil :foreground "#444444" :background "white")
  ;;   (set-face-attribute 'term-color-white nil :foreground "black"))

  (add-hook 'term-exec-hook
            (function
             (lambda ()
               (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))))

  ;; Allow pasting text to be sent to the underlying shell process.
  (add-hook
   'term-mode-hook
   (lambda ()
     (define-key term-raw-map (kbd "C-y") 'term-paste)
     (define-key term-raw-map (kbd "C-v") 'term-paste)
     (define-key term-raw-map (kbd "s-v") 'term-paste)))
#+end_src

** catch-all (old 'theme' file)

I used to put everything that wasn't explicitly part of a package
configuration into the "theme" config file. Here's all that remains
and all that needs to be integrated into the above outline.

#+begin_src emacs-lisp :tangle yes
  (delete-selection-mode 1)
  (tool-bar-mode 0)
  (setq scroll-step 1)

  (setq make-backup-files nil)
  (setq auto-save-default nil)

  (if window-system
      (progn (scroll-bar-mode 0)
             (global-hl-line-mode 1)
             (fringe-mode '(6 . 6)))
    (progn (global-hl-line-mode 1)
           (set-face-background hl-line-face "gray13")
           (menu-bar-mode 0)))

  (column-number-mode 1)
  (cua-mode 1)
  (show-paren-mode t)
  (custom-set-variables '(indent-tabs-mode nil))
  (setq-default line-spacing 1)
  (setq-default inhibit-startup-screen t)
  (setq-default standard-indent 2)
  (setq-default tab-width 2)
  (add-hook 'before-save-hook 'whitespace-cleanup)
  (set-face-attribute 'default nil :family "Input Mono Narrow" :height 120 :weight 'thin)
  ;;(set-face-attribute 'default nil :family "Inconsolata" :height 140 :weight 'normal)
  ;;(set-face-attribute 'default nil :family "Monaco" :height 120 :weight 'normal)
  (blink-cursor-mode 0)
  (set-default 'cursor-type 'hollow)
  (setq ring-bell-function 'ignore)

  (when window-system
    ;;
    ;; Not sure if this works.
    (defun kfi-fix-echo-area ()
      (interactive)
      (with-current-buffer (get-buffer " *Echo Area 0*")
        (setq-local face-remapping-alist '((default :family "Input Mono Narrow" :weight thin :height 100)))))

    ;; Make minibuffer have a smaller font
    (add-hook 'minibuffer-setup-hook 'kfi-craft-minibuffer)

    (defun kfi-craft-minibuffer ()
      (interactive)
      (set (make-local-variable 'face-remapping-alist)
           '((default :family "Input Mono Narrow" :weight thin :height 100))))

    (kfi-fix-echo-area)
    (kfi-craft-minibuffer))

  (setq ns-use-srgb-colorspace t)
#+end_src


* Sync buffers to what's on the file system

/Docs:/ Global Auto Revert mode is a global minor mode that reverts any buffer
associated with a file when the file changes on disk.

#+begin_src emacs-lisp :tangle yes
  (global-auto-revert-mode 1)
#+end_src

* Do not wrap lines when they're too long

#+begin_src emacs-lisp :tangle yes
  (setq-default truncate-lines t)
#+end_src

* Don't attach a postamble to org-mode exports

#+begin_src emacs-lisp :tangle yes
  (setq org-html-postamble nil)
#+end_src

* Extend the EOL column

I've got truncate long lines on, but this should be appropriate for text
oriented buffers like, say, the one in which I edit this file.

#+begin_src emacs-lisp :tangle yes
  (setq fill-column 80)
#+end_src

* Try for a smooth scrolling experience

Courtesy of [[https://github.com/joodie/emacs-literal-config/blob/master/emacs.org][Joost Diepenmaat]] at [[https://github.com/joodie][Github]].

#+begin_src emacs-lisp :tangle yes
  (setq redisplay-dont-pause t
        scroll-margin 1
        scroll-step 1
        scroll-conservatively 10000
        scroll-preserve-screen-position 1)

  (setq mouse-wheel-follow-mouse 't)
  (setq mouse-wheel-scroll-amount '(quote (0.01)))
#+end_src

* Banish custom config to another file

If I use any of the custom config facility, I want that stuff to go to
a separate file:

#+begin_src emacs-lisp :tangle yes
  (setq custom-file "~/.emacs.d/custom.el")
  ;; (load custom-file)
#+end_src

And I'm not even going to load it. The goal (for me) is to never need
that file. So, uh, there.

* UTF8 encoding

Is this kind of thing still needed? I see it in other peoples' config
files, but I've never knowingly had a problem with glyphs.

#+begin_src emacs-lisp :tangle yes
  (prefer-coding-system 'utf-8)
  (when (display-graphic-p)
    (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

* Yes or no

#+begin_src emacs-lisp :tangle yes
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

* dark theme: atom-one-dark

This is my main theme. Bright where it needs to be, but nowhere
else. I've added a command =kfi-dark= to invoke the theme after
invoking =kfi-light= (see below).

#+begin_src emacs-lisp :tangle yes
  (use-package atom-one-dark-theme
    :if window-system
    :ensure t
    :config
    (defun kfi-dark ()
      (interactive)
      (load-theme 'atom-one-dark t)
      (set-face-attribute 'fringe nil :background "black")
      (set-face-attribute 'default nil :background "black")
      (set-face-attribute 'mode-line nil :background "#292c34")

      (set-face-attribute 'mode-line nil
                          :foreground "#ccc"
                          :background "#374350"
                          :underline nil
                          :family "Input Mono Narrow" :height 100 :weight 'thin
                          :box '(:line-width 2 :color "#374350" :style nil))

      (set-face-attribute 'mode-line-inactive nil :foreground "gray60"
                          :background "gray15" :family "Input Mono Narrow" :height 100
                          :weight 'thin :italic nil
                          :box '(:line-width 2 :color "gray15" :style nil))


      (set-face-attribute 'region nil :background "#3E4451")

      ;; Linum customization
      (set-face-attribute 'linum nil :foreground "#555")

      ;; ERC customizations
      (set-face-attribute 'erc-prompt-face nil
                          :foreground "darkorange"
                          ;;:background "#212121"
                          :background "black"
                          )

      (set-face-attribute 'erc-timestamp-face nil
                          :foreground "gray30"
                          ;; :background "#292c34"
                          :background "black"))


    (when window-system
      ;; Test not necessary.
      (kfi-dark))
    )
#+end_src

* light theme: default

Sometimes I want the default white Emacs theme, so:

#+begin_src emacs-lisp :tangle yes
  (defun kfi-light ()
    (interactive)
    (disable-theme 'atom-one-dark)
    (set-face-attribute 'fringe nil :background "#fff")
    (set-face-attribute 'default nil :background "#fff")
    ;; (set-face-background hl-line-face "gray90")

    (set-face-attribute 'mode-line nil
                        :foreground "dodgerblue"
                        :background "gray90"
                        :underline nil
                        :family "Input Mono Narrow" :height 100 :weight 'thin
                        :box '(:line-width 2 :color "gray90" :style nil))

    (set-face-attribute 'mode-line-inactive nil :foreground "gray60"
                        :background "#f2f2f2" :family "Input Mono Narrow" :height 100
                        :weight 'thin :italic nil
                        :box '(:line-width 2 :color "#f2f2f2" :style nil))

    ;;(sml/apply-theme 'light)
    (set-face-attribute 'region nil :background "aquamarine")

    ;; Linum customization
    (set-face-attribute 'linum nil :foreground "#ccc")

    ;; ERC customizations
    (set-face-attribute 'erc-prompt-face nil
                        :foreground "dodgerblue" :background "white")
    (set-face-attribute 'erc-timestamp-face nil
                        :foreground "dodgerblue" :background "white"))

  ;; (when window-system
  ;;   (kfi-light))
#+end_src
* transparency stuff

#+begin_src emacs-lisp :tangle yes
  (defun kfi-transparency ()
    (interactive)
    (set-frame-parameter nil 'alpha '(90 90))
    (add-to-list 'default-frame-alist '(alpha 90 90)))

  (defun kfi-transparency-no ()
    (interactive)
    (set-frame-parameter nil 'alpha '(100 100))
    (add-to-list 'default-frame-alist '(alpha 100 100)))
#+end_src
